<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Обработка прерываний | Разработка ОС</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="osdev.org на русском">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/osdev/assets/css/0.styles.cf6cd58c.css" as="style"><link rel="preload" href="/osdev/assets/js/app.3c540b81.js" as="script"><link rel="preload" href="/osdev/assets/js/2.09df5680.js" as="script"><link rel="preload" href="/osdev/assets/js/12.f99e982a.js" as="script"><link rel="prefetch" href="/osdev/assets/js/10.f59a9f37.js"><link rel="prefetch" href="/osdev/assets/js/11.32aede7f.js"><link rel="prefetch" href="/osdev/assets/js/13.0e02a79c.js"><link rel="prefetch" href="/osdev/assets/js/14.e42164ce.js"><link rel="prefetch" href="/osdev/assets/js/15.2cc01d27.js"><link rel="prefetch" href="/osdev/assets/js/16.23958917.js"><link rel="prefetch" href="/osdev/assets/js/17.33e975cd.js"><link rel="prefetch" href="/osdev/assets/js/3.4032e2a1.js"><link rel="prefetch" href="/osdev/assets/js/4.09ee8a39.js"><link rel="prefetch" href="/osdev/assets/js/5.c661e667.js"><link rel="prefetch" href="/osdev/assets/js/6.aa86b854.js"><link rel="prefetch" href="/osdev/assets/js/7.2ffd272d.js"><link rel="prefetch" href="/osdev/assets/js/8.05215729.js"><link rel="prefetch" href="/osdev/assets/js/9.f7a7992e.js">
    <link rel="stylesheet" href="/osdev/assets/css/0.styles.cf6cd58c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/osdev/" class="home-link router-link-active"><!----> <span class="site-name">Разработка ОС</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/osdev/intro/" class="nav-link router-link-active">
  Введение
</a></div><div class="nav-item"><a href="/osdev/hardware/" class="nav-link">
  Аппаратная часть
</a></div><div class="nav-item"><a href="/osdev/os/" class="nav-link">
  Конструкция ОС
</a></div><div class="nav-item"><a href="/osdev/resources/" class="nav-link">
  Ресурсы
</a></div><div class="nav-item"><a href="/osdev/reference/" class="nav-link">
  Справочная информация
</a></div><div class="nav-item"><a href="/osdev/tools/" class="nav-link">
  Утилиты
</a></div><div class="nav-item"><a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Оригинал
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/osdev/intro/" class="nav-link router-link-active">
  Введение
</a></div><div class="nav-item"><a href="/osdev/hardware/" class="nav-link">
  Аппаратная часть
</a></div><div class="nav-item"><a href="/osdev/os/" class="nav-link">
  Конструкция ОС
</a></div><div class="nav-item"><a href="/osdev/resources/" class="nav-link">
  Ресурсы
</a></div><div class="nav-item"><a href="/osdev/reference/" class="nav-link">
  Справочная информация
</a></div><div class="nav-item"><a href="/osdev/tools/" class="nav-link">
  Утилиты
</a></div><div class="nav-item"><a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Оригинал
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Введение</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/osdev/intro/" aria-current="page" class="sidebar-link">Главная</a></li><li><a href="/osdev/intro/required.html" class="sidebar-link">Необходимые знания</a></li><li><a href="/osdev/intro/mistakes.html" class="sidebar-link">Ошибки начинающих</a></li><li><a href="/osdev/intro/getting-started.html" class="sidebar-link">Начало работы</a></li><li><a href="/osdev/intro/kcl-linking.html" class="sidebar-link">Как ядро, компилятор и код на C работают вместе</a></li><li><a href="/osdev/intro/isr.html" aria-current="page" class="active sidebar-link">Обработка прерываний</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/osdev/intro/isr.html#isr-interrupt-service-routine" class="sidebar-link">ISR - Interrupt Service Routine</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/isr.html#когда-вызываются-обработчики" class="sidebar-link">Когда вызываются обработчики</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/isr.html#проблема" class="sidebar-link">Проблема</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/isr.html#решения" class="sidebar-link">Решения</a></li></ul></li><li><a href="/osdev/intro/languages.html" class="sidebar-link">Языки программирования</a></li><li><a href="/osdev/intro/uefi.html" class="sidebar-link">UEFI</a></li><li><a href="/osdev/intro/bios.html" class="sidebar-link">BIOS</a></li><li><a href="/osdev/intro/inline-asm.html" class="sidebar-link">Встроенная сборка</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="обработка-прерывании"><a href="#обработка-прерывании" class="header-anchor">#</a> Обработка прерываний</h1> <h2 id="isr-interrupt-service-routine"><a href="#isr-interrupt-service-routine" class="header-anchor">#</a> ISR - Interrupt Service Routine</h2> <p>Архитектура x86 - это система, управляемая прерываниями. Внешние события вызывают прерывание — прерывается нормальный поток управления и вызывается процедура обработки прерываний (ISR).</p> <p>Такие события могут быть вызваны аппаратным или программным обеспечением. Примером аппаратного прерывания является клавиатура: каждый раз, когда вы нажимаете кнопку, клавиатура запускает IRQ1 (Запрос на прерывание 1), и вызывается соответствующий обработчик прерывания. Таймеры и завершение запроса на диск являются другими возможными источниками аппаратных прерываний.</p> <p>Прерывания, управляемые программным обеспечением, запускаются кодом операции int; например, службы MS-DOS, вызываются программным обеспечением, запускающим INT 21h и передающим соответствующие параметры в регистрах процессора.</p> <p>Чтобы система знала, какую процедуру обработки прерываний вызывать при возникновении определенного прерывания, смещения для ISR хранятся в Interrupt Descriptor Table, когда вы находитесь в Protected Mode, или Interrupt Vector Table, когда вы находитесь в Real Mode.</p> <p>ISR вызывается непосредственно процессором, и протокол для вызова ISR отличается от вызова, например, функции C. Самое главное, ISR должен заканчиваться кодом операции iret (или iretq в Long Mode — да, даже при использовании синтаксиса Intel), в то время как обычные функции C заканчиваются ret или retf. Очевидное, но тем не менее неправильное решение приводит к одной из самых &quot;популярных&quot; тройной ошибки среди программистов ОС.</p> <h2 id="когда-вызываются-обработчики"><a href="#когда-вызываются-обработчики" class="header-anchor">#</a> Когда вызываются обработчики</h2> <h3 id="x86"><a href="#x86" class="header-anchor">#</a> x86</h3> <p>Когда процессор вызывает обработчики прерываний, процессор помещает эти значения в стек в следующем порядке:</p> <div class="language- extra-class"><pre class="language-text"><code>EFLAGS -&gt; CS -&gt; EIP
</code></pre></div><p>Значение CS дополняется двумя байтами, чтобы сформировать двойное слово.</p> <p>Если тип шлюза не является прерыванием, процессор очистит флаг прерывания. Если прерывание является исключением, процессор отправит код ошибки в стек в виде двойного слова.</p> <p>Процессор загрузит значение селектора сегментов из связанного дескриптора IDT в CS.</p> <h3 id="x86-64"><a href="#x86-64" class="header-anchor">#</a> x86-64</h3> <p>Когда процессор вызывает обработчики прерываний, он изменяет значение в регистре RSP на значение, указанное в IST, и если его нет, стек остается прежним. В новый стек процессор помещает эти значения в следующем порядке:</p> <div class="language- extra-class"><pre class="language-text"><code>SS:RSP (original RSP) -&gt; RFLAGS -&gt; CS -&gt; RIP
</code></pre></div><p>CS дополняется, чтобы сформировать четырехсловие.</p> <p>Если прерывание вызывается из другого кольца, SS устанавливается в 0, что указывает на нулевой селектор. Процессор изменит регистр RFLAGS, установив биты TF, NT и RF равными 0. Если тип прерывание, процессор очистит флаг прерывания.</p> <p>Если прерывание является исключением, процессор отправит код ошибки в стек, дополненный байтами, чтобы сформировать четырехсловие.</p> <p>Процессор загрузит значение селектора сегментов из связанного дескриптора IDT в CS и проверит, является ли CS допустимым селектором сегментов кода.</p> <h2 id="проблема"><a href="#проблема" class="header-anchor">#</a> Проблема</h2> <p>Многие люди избегают ассемблера и хотят сделать как можно больше на своем любимом языке высокого уровня. GCC (а также другие компиляторы) позволяют добавлять встроенный ассемблер, поэтому многие программисты испытывают соблазн написать ISR, подобный этому:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Как НЕ НУЖНО писать обработчик прерываний */</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;pushad&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Сохранение регистров */</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
    <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;popad&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Восстанавливаем регистры */</span>
    <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;iret&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* Ура! Ура! Тройная ошибка */</span>
    <span class="token comment">/* Думаем о своём поведении и переписываем код правильно */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Это не будет работать. Компилятор не понимает, что происходит. Он не понимает, что регистры и стек должны сохраняться между операторами asm; оптимизатор, скорее всего, повредит функцию. Кроме того, компилятор добавляет код обработки стека до и после вашей функции, что вместе с iret приводит к коду ассемблера, похожему на этот:</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>push   <span class="token operator">%</span><span class="token register variable">ebp</span>
mov    <span class="token operator">%</span><span class="token register variable">esp</span>,<span class="token operator">%</span><span class="token register variable">ebp</span>
sub    <span class="token operator">$</span><span class="token operator">&lt;</span>размер локальных переменных<span class="token operator">&gt;</span>,<span class="token operator">%</span><span class="token register variable">esp</span>
pushad
# C код пишем здесь
popad
iret
# <span class="token string">'leave'</span> если вы используете локальные переменные, <span class="token string">'pop %ebp'</span> для остальных случаев.
leave
ret
</code></pre></div><p>Должно быть очевидно, как это портит стек (ebp выталкивается, но никогда не выскакивает). Не делай этого.</p> <h2 id="решения"><a href="#решения" class="header-anchor">#</a> Решения</h2> <h3 id="чистыи-ассемблер"><a href="#чистыи-ассемблер" class="header-anchor">#</a> Чистый Ассемблер</h3> <p>Узнайте достаточно об ассемблере, чтобы написать в нём обработчики прерываний 😃</p> <h3 id="двухэтапныи-враппер-ассемблера"><a href="#двухэтапныи-враппер-ассемблера" class="header-anchor">#</a> Двухэтапный враппер ассемблера</h3> <p>Напишите оболочку ассемблера, вызывающую функцию C для выполнения обработки, и только затем выполните iret.</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token operator">/</span><span class="token operator">*</span> Файл: isr_wrapper.s <span class="token operator">*</span><span class="token operator">/</span>
.globl   isr_wrapper
.align   <span class="token number">4</span>
 
<span class="token label function">isr_wrapper:</span>
    pushad
    cld <span class="token operator">/</span><span class="token operator">*</span> Код C, следующий за sysV ABI, требует, чтобы DF был очищен при выполнении функции <span class="token operator">*</span><span class="token operator">/</span>
    call interrupt_handler
    popad
    iret
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Файл: interrupt_handler.c */</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="директивы-прерывании-специфичные-для-компилятора"><a href="#директивы-прерывании-специфичные-для-компилятора" class="header-anchor">#</a> Директивы прерываний специфичные для компилятора</h3> <p>Некоторые компиляторы для некоторых процессоров имеют директивы, позволяющие объявлять обычное прерывание, предлагая #pragma interrupt или выделенный макрос. Clang 3.9, Borland C, Watcom C/C++, Microsoft C 6.0 и GCC предлагают это. Visual C++ предлагает альтернативу, показанную в разделе <strong>Naked-функции</strong>:</p> <h4 id="clang"><a href="#clang" class="header-anchor">#</a> Clang</h4> <p>Начиная с версии 3.9, он поддерживает атрибут прерывания для x86/x86-64.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">interrupt_frame</span> <span class="token punctuation">{</span>
    <span class="token class-name">uword_t</span> ip<span class="token punctuation">;</span>
    <span class="token class-name">uword_t</span> cs<span class="token punctuation">;</span>
    <span class="token class-name">uword_t</span> flags<span class="token punctuation">;</span>
    <span class="token class-name">uword_t</span> sp<span class="token punctuation">;</span>
    <span class="token class-name">uword_t</span> ss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interrupt<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">interrupt_frame</span> <span class="token operator">*</span> frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="borland-c"><a href="#borland-c" class="header-anchor">#</a> Borland C</h4> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> interrupt <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="watcom-c-c"><a href="#watcom-c-c" class="header-anchor">#</a> Watcom C/C++</h4> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> _interrupt <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="naked-функции"><a href="#naked-функции" class="header-anchor">#</a> Naked-функции</h4> <p>Некоторые компиляторы могут использоваться для создания процедур прерывания, но требуют, чтобы вы вручную обрабатывали операции стека и возврата. Для этого требуется, чтобы функция создавалась без эпилога или пролога. Это называется сделать функцию <strong>naked</strong> — это делается в Visual C++ путем добавления атрибута <em>_declspec(naked)</em> к функции. Вам необходимо убедиться, что вы включаете операцию возврата (например, iretd), поскольку это часть эпилога, который компилятору теперь было поручено не включать.</p> <p>Если вы собираетесь использовать локальные переменные, вы должны настроить фрейм стека так, как ожидает компилятор; однако, поскольку ISR не являются реентерабельными, вы можете просто использовать статические переменные.</p> <h4 id="microsoft-visual-c"><a href="#microsoft-visual-c" class="header-anchor">#</a> Microsoft Visual C++</h4> <p>Visual C++ предоставляет макрос ассемблера __LOCAL_SIZE, который уведомляет вас, сколько места требуется объектам в стеке для функции.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">_declspec</span><span class="token punctuation">(</span>naked<span class="token punctuation">)</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _asm pushad<span class="token punctuation">;</span>
 
    <span class="token comment">/* Делаем что-нибудь */</span>
 
    _asm <span class="token punctuation">{</span>
        popad
        iretd
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="gcc-g"><a href="#gcc-g" class="header-anchor">#</a> GCC / G++</h4> <p>В <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html#x86-Function-Attributes" target="_blank" rel="noopener noreferrer">документации GCC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> говорится, что, используя атрибуты функций GCC, они добавили возможность писать обработчики прерываний в интерфейсе C с помощью _<em>attribute</em>_((interrupt)). Так что вместо:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* ЧЁРНАЯ МАГИЯ - категорически не рекомендуется! */</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">&quot;pushad&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">&quot;popad; leave; iret&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* ЧЁРНАЯ МАГИЯ! */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Вы можете использовать:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">interrupt_frame</span><span class="token punctuation">;</span>
 
<span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>interrupt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">interrupt_frame</span><span class="token operator">*</span> frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>В документации для GCC говорится, что если используется атрибут прерывания, инструкция iret будет использоваться вместо ret на архитектурах x86 и x86-64. В нем также говорится: &quot;Поскольку GCC не сохраняет состояния SSE, MMX и x87, параметр GCC-mgeneral-regs-only должен использоваться для компиляции обработчиков прерываний и исключений.&quot;</p> <h5 id="черная-магия"><a href="#черная-магия" class="header-anchor">#</a> Чёрная магия</h5> <p>Посмотрите на неисправный код выше, где правильный exit-код функции C был пропущен, что испортило стек. Теперь рассмотрим этот фрагмент кода, где код выхода добавляется вручную:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* ЧЁРНАЯ МАГИЯ - категорически не рекомендуется! */</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">&quot;pushad&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Делаем что-нибудь */</span>
    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">&quot;popad; leave; iret&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* ЧЁРНАЯ МАГИЯ! */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Ассемблерный код будет выглядеть примерно так:</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>push   <span class="token operator">%</span><span class="token register variable">ebp</span>
mov    <span class="token operator">%</span><span class="token register variable">esp</span>,<span class="token operator">%</span><span class="token register variable">ebp</span>
sub    <span class="token operator">$</span><span class="token operator">&lt;</span>размер локальных переменных<span class="token operator">&gt;</span>,<span class="token operator">%</span><span class="token register variable">esp</span>
pushad
# C<span class="token operator">-</span>код где<span class="token operator">-</span>то здесь
popad
leave
iret
leave # мёртвый код
ret   # мёртвый код
</code></pre></div><p>Это предполагает, что leave является правильной обработкой конца функции - вы выполняете код возврата функции &quot;вручную&quot;, а обработку, сгенерированную компилятором, оставляете как &quot;мертвый код&quot;. Излишне говорить, что такие предположения о внутренних компонентах компилятора опасны. Этот код может сломаться на другом компиляторе или даже на другой версии того же компилятора. Поэтому он настоятельно не рекомендуется и указан только для полноты картины.</p> <h5 id="assembly-goto"><a href="#assembly-goto" class="header-anchor">#</a> Assembly Goto</h5> <p>Начиная с версии 4.5, GCC поддерживает оператор &quot;asm goto&quot;. Он может быть использован для создания ISR в качестве функций, которые возвращают правильный адрес точки входа ISR.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/osdev/intro/kcl-linking.html" class="prev">
        Как ядро, компилятор и код на C работают вместе
      </a></span> <span class="next"><a href="/osdev/intro/languages.html">
        Языки программирования
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/osdev/assets/js/app.3c540b81.js" defer></script><script src="/osdev/assets/js/2.09df5680.js" defer></script><script src="/osdev/assets/js/12.f99e982a.js" defer></script>
  </body>
</html>
