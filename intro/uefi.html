<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>UEFI | Разработка ОС</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="osdev.org на русском">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/osdev/assets/css/0.styles.cf6cd58c.css" as="style"><link rel="preload" href="/osdev/assets/js/app.6d4e7c16.js" as="script"><link rel="preload" href="/osdev/assets/js/2.d8a8b755.js" as="script"><link rel="preload" href="/osdev/assets/js/25.f01e693e.js" as="script"><link rel="prefetch" href="/osdev/assets/js/10.f52dfc28.js"><link rel="prefetch" href="/osdev/assets/js/11.62d004c8.js"><link rel="prefetch" href="/osdev/assets/js/12.de6a66d3.js"><link rel="prefetch" href="/osdev/assets/js/13.5ce18855.js"><link rel="prefetch" href="/osdev/assets/js/14.2418957f.js"><link rel="prefetch" href="/osdev/assets/js/15.c118d926.js"><link rel="prefetch" href="/osdev/assets/js/16.d7ace87c.js"><link rel="prefetch" href="/osdev/assets/js/17.ed033aaf.js"><link rel="prefetch" href="/osdev/assets/js/18.fd5dcd0e.js"><link rel="prefetch" href="/osdev/assets/js/19.401c7b19.js"><link rel="prefetch" href="/osdev/assets/js/20.69a7aab0.js"><link rel="prefetch" href="/osdev/assets/js/21.aa99a090.js"><link rel="prefetch" href="/osdev/assets/js/22.21e5a0d1.js"><link rel="prefetch" href="/osdev/assets/js/23.25b4c5a4.js"><link rel="prefetch" href="/osdev/assets/js/24.e3d90789.js"><link rel="prefetch" href="/osdev/assets/js/3.9d834bc1.js"><link rel="prefetch" href="/osdev/assets/js/4.15995e12.js"><link rel="prefetch" href="/osdev/assets/js/5.3392b390.js"><link rel="prefetch" href="/osdev/assets/js/6.a16b59c6.js"><link rel="prefetch" href="/osdev/assets/js/7.5089196a.js"><link rel="prefetch" href="/osdev/assets/js/8.83af78e0.js"><link rel="prefetch" href="/osdev/assets/js/9.f2730610.js">
    <link rel="stylesheet" href="/osdev/assets/css/0.styles.cf6cd58c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/osdev/" class="home-link router-link-active"><!----> <span class="site-name">Разработка ОС</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/osdev/intro/" class="nav-link router-link-active">
  Введение
</a></div><div class="nav-item"><a href="/osdev/teapot/" class="nav-link">
  Гайд для чайников
</a></div><div class="nav-item"><a href="/osdev/hardware/" class="nav-link">
  Аппаратная часть
</a></div><div class="nav-item"><a href="/osdev/os/" class="nav-link">
  Конструкция ОС
</a></div><div class="nav-item"><a href="/osdev/resources/" class="nav-link">
  Ресурсы
</a></div><div class="nav-item"><a href="/osdev/reference/" class="nav-link">
  Справочная информация
</a></div><div class="nav-item"><a href="/osdev/tools/" class="nav-link">
  Утилиты
</a></div><div class="nav-item"><a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Оригинал
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/osdev/intro/" class="nav-link router-link-active">
  Введение
</a></div><div class="nav-item"><a href="/osdev/teapot/" class="nav-link">
  Гайд для чайников
</a></div><div class="nav-item"><a href="/osdev/hardware/" class="nav-link">
  Аппаратная часть
</a></div><div class="nav-item"><a href="/osdev/os/" class="nav-link">
  Конструкция ОС
</a></div><div class="nav-item"><a href="/osdev/resources/" class="nav-link">
  Ресурсы
</a></div><div class="nav-item"><a href="/osdev/reference/" class="nav-link">
  Справочная информация
</a></div><div class="nav-item"><a href="/osdev/tools/" class="nav-link">
  Утилиты
</a></div><div class="nav-item"><a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Оригинал
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Введение</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/osdev/intro/" aria-current="page" class="sidebar-link">Главная</a></li><li><a href="/osdev/intro/required.html" class="sidebar-link">Необходимые знания</a></li><li><a href="/osdev/intro/mistakes.html" class="sidebar-link">Ошибки начинающих</a></li><li><a href="/osdev/intro/getting-started.html" class="sidebar-link">Начало работы</a></li><li><a href="/osdev/intro/kcl-linking.html" class="sidebar-link">Как ядро, компилятор и код на C работают вместе</a></li><li><a href="/osdev/intro/isr.html" class="sidebar-link">Обработка прерываний</a></li><li><a href="/osdev/intro/languages.html" class="sidebar-link">Языки программирования</a></li><li><a href="/osdev/intro/uefi.html" aria-current="page" class="active sidebar-link">UEFI</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#основная-информация" class="sidebar-link">Основная информация</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#основы-uefi" class="sidebar-link">Основы UEFI</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#разработка-с-posix-uefi" class="sidebar-link">Разработка с POSIX-UEFI</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#разработка-с-gnu-efi" class="sidebar-link">Разработка с GNU-EFI</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#эмуляция-с-qemu-и-ovmf" class="sidebar-link">Эмуляция с QEMU и OVMF</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#запуск-на-реальном-железе" class="sidebar-link">Запуск на реальном железе</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#uefi-приложения-в-деталях" class="sidebar-link">UEFI-приложения в деталях</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#основные-проблемы" class="sidebar-link">Основные проблемы</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/uefi.html#внешние-ссылки" class="sidebar-link">Внешние ссылки</a></li></ul></li><li><a href="/osdev/intro/bios.html" class="sidebar-link">BIOS</a></li><li><a href="/osdev/intro/inline-asm.html" class="sidebar-link">Встроенная сборка</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Первые шаги</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/osdev/first-steps/bare-bones.html" class="sidebar-link">Голое железо</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="uefi"><a href="#uefi" class="header-anchor">#</a> UEFI</h1> <h2 id="основная-информация"><a href="#основная-информация" class="header-anchor">#</a> Основная информация</h2> <p>(U)EFI или (Унифицированный) Расширяемый Интерфейс микропрограммного обеспечения - это спецификация для платформ x86, x86-64, ARM и Itanium, которая определяет программный интерфейс между операционной системой и микропрограммным обеспечением платформы/BIOS. Оригинальный EFI был разработан в середине 1990-х годов компанией Intel для разработки встроенного ПО/BIOS для платформ Itanium. В 2005 году Intel передала спецификацию новой рабочей группе под названием Unified EFI Forum, состоящей из таких компаний, как AMD, Microsoft, Apple и сама Intel. Все современные ПК поставляются с прошивкой UEFI, UEFI широко поддерживается как коммерческими, так и операционными системами с открытым исходным кодом. Обратная совместимость предусмотрена для устаревших операционных систем.</p> <h2 id="основы-uefi"><a href="#основы-uefi" class="header-anchor">#</a> Основы UEFI</h2> <h3 id="загрузка-образов-uefi"><a href="#загрузка-образов-uefi" class="header-anchor">#</a> Загрузка образов UEFI</h3> <p>Если вы используете VirtualBox для виртуализации, то UEFI уже включен, нет необходимости загружать образ вручную. Вам просто нужно включить его в настройках виртуальной машины, нажав флажок &quot;Настройки&quot; / &quot;Системы&quot; / &quot;Включить EFI (только специальные операционные системы)&quot;.</p> <p>В противном случае для эмуляции и виртуальных машин вам понадобится образ прошивки OVMF.fd. Это может быть сложно найти, поэтому вот несколько альтернативных ссылок для загрузки:</p> <ul><li><a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF" target="_blank" rel="noopener noreferrer">TianoCore<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/BlankOn/ovmf-blobs" target="_blank" rel="noopener noreferrer">OVMF-blobs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.kraxel.org/repos/" target="_blank" rel="noopener noreferrer">RPM packages<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://packages.debian.org/sid/ovmf" target="_blank" rel="noopener noreferrer">Debian packages<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://packages.gentoo.org/useflags/ovmf" target="_blank" rel="noopener noreferrer">Gentoo packages<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://aur.archlinux.org/packages/ovmf-git/?comments=all" target="_blank" rel="noopener noreferrer">Arch packages<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>В Linux вы также можете установить их с помощью диспетчера пакетов вашего дистрибутива, например:</p> <h4 id="debian-ubuntu"><a href="#debian-ubuntu" class="header-anchor">#</a> Debian / Ubuntu</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">apt-get</span> <span class="token function">install</span> ovmf
</code></pre></div><h4 id="redhat-centos"><a href="#redhat-centos" class="header-anchor">#</a> RedHat / CentOS</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>yum <span class="token function">install</span> ovmf
</code></pre></div><h4 id="macos"><a href="#macos" class="header-anchor">#</a> macOS</h4> <p>Используйте репозиторий OVMF-blobs.</p> <h4 id="windows"><a href="#windows" class="header-anchor">#</a> Windows</h4> <p>Используйте репозиторий OVMF-blobs или загрузите RPM-версию, затем с помощью 7-Zip распакуйте файл OVMF.fd из загруженного архива.</p> <h3 id="uefi-против-bios"><a href="#uefi-против-bios" class="header-anchor">#</a> UEFI против BIOS</h3> <p>Распространенным заблуждением является то, что UEFI является заменой BIOS. На самом деле, как устаревшие материнские платы, так и материнские платы на основе UEFI поставляются с ПЗУ BIOS, которые содержат встроенное ПО, которое выполняет начальную настройку системы при включении питания, прежде чем загружать какой-либо сторонний код в память и переходить к нему. Различия между устаревшей прошивкой BIOS и прошивкой UEFI BIOS заключаются в том, где они находят этот код, как они готовят систему перед переходом к ней и какие удобные функции они предоставляют для вызова кода во время работы.</p> <h4 id="инициализация-платформы"><a href="#инициализация-платформы" class="header-anchor">#</a> Инициализация платформы</h4> <p>BIOS выполняет всю инициализацию платформы (конфигурация контроллера памяти, конфигурация шины PCI и BAR-mapping, инициализация видеокарты и т.д.), но затем переходит в обратно совместимую среду Real Mode. Загрузчик должен включить A20-gate, настроить GDT и IDT, переключиться в Protected Mode, а для процессоров x86-64 настроить подкачку и переключиться в Long Mode.</p> <p>Прошивка UEFI выполняет те же шаги, но также подготавливает среду Protected Mode с плоской сегментацией, а для процессоров x86-64-среду Long mode с отображением идентификаторов подкачки. A20-gate также включён.</p> <p>Кроме того, процедура инициализации платформы прошивки UEFI стандартизирована. Это позволяет распространять прошивку UEFI независимо от поставщика платы.</p> <h4 id="механизм-загрузки"><a href="#механизм-загрузки" class="header-anchor">#</a> Механизм загрузки</h4> <p>BIOS загружает 512-байтовый двоичный объект из загрузочного устройства типа MBR(Master Boot Record) в память по физическому адресу 7C00 и переходит к нему. Загрузчик не может вернуться обратно в BIOS. Прошивка UEFI загружает приложение UEFI произвольного размера (исполняемый файл PE) из раздела FAT на загрузочном устройстве с разделом GPT на некоторый адрес, выбранный во время выполнения. Затем он вызывает основную точку входа этого приложения. Приложение может вернуть управление встроенному ПО, которое продолжит поиск другого загрузочного устройства или вызовет меню диагностики.</p> <h4 id="обнаружение-системы"><a href="#обнаружение-системы" class="header-anchor">#</a> Обнаружение системы</h4> <p>BIOS сканирует память на наличие таких структур, как таблицы EBDA, SMBIOS и ACPI. Он использует PIO для связи с корневым контроллером PCI и сканирования шины PCI. Возможно, что в памяти могут присутствовать избыточные таблицы (например, таблица MP в SMBIOS содержит информацию, которая также присутствует в DSDT ACPI), и загрузчик может выбрать, какие из них использовать.</p> <p>Когда UEFI вызывает функцию точки входа UEFI-приложения, она передает структуру &quot;Системной таблицы&quot;, которая содержит указатели на все таблицы ACPI системы, карту памяти и другую информацию, относящуюся к ОС. Устаревшие таблицы (например, SMBIOS) могут отсутствовать в памяти.</p> <h4 id="удобные-функции"><a href="#удобные-функции" class="header-anchor">#</a> Удобные функции</h4> <p>BIOS подключает различные прерывания, которые загрузчик может запускать для доступа к системным ресурсам, таким как диски и экран. Эти прерывания не стандартизированы, за исключением исторических условностей. Каждое прерывание использует другое для передачи регистра.</p> <p>UEFI устанавливает в памяти множество вызываемых функций, которые группируются в наборы, называемые &quot;протоколами&quot;, и которые можно обнаружить через системную таблицу. Поведение каждой функции в каждом протоколе определяется спецификацией. Приложения UEFI могут определять свои собственные протоколы и сохранять их в памяти для использования другими UEFI-приложениями. Функции вызываются с помощью стандартизированного, современного стандарта системных вызовов, поддерживаемого многими компиляторами языка C.</p> <h4 id="среда-разработки"><a href="#среда-разработки" class="header-anchor">#</a> Среда разработки</h4> <p>Устаревшие загрузчики могут быть разработаны в любой среде, которая может генерировать двоичные образы: NASM, GCC и т.д. Приложения UEFI могут быть разработаны на любом языке, который может быть скомпилирован и связан в исполняемый файл PE и поддерживает соответствующие вызовы, используемые для доступа к функциям, установленным в памяти прошивкой UEFI. На практике это означает одну из двух сред разработки: Intel TianoCore EDK2, GNU-EFI или POSIX-UEFI.</p> <p>TianoCore - это большая, сложная среда с собственной системой сборки. Его можно настроить для использования вместе с GCC, MinGW, Microsoft Visual C++ и т.д. Его можно использовать не только для компиляции UEFI-приложений, но и для компиляции прошивки UEFI, которая будет перенесена в ПЗУ BIOS.</p> <p>GNU-EFI - это набор библиотек и заголовков для компиляции приложений UEFI с собственным GCC системы (не работает с LLVM CLang). Он не может быть использован для компиляции прошивки UEFI. Поскольку это всего лишь пара библиотек, с которыми можно связать UEFI-приложение, его гораздо проще использовать, чем TianoCore.</p> <p>POSIX-UEFI очень похож на GNU-EFI, но он распространяется в основном как исходный код, а не как двоичная библиотека, имеет имена, подобные ANSI C, и работает с GCC, а также с LLVM CLang. Он поставляется с файлом Makefile.</p> <h4 id="эмуляция"><a href="#эмуляция" class="header-anchor">#</a> Эмуляция</h4> <p>Bochs поставляется с BIOS с открытым исходным кодом по умолчанию. Кроме того, SeaBIOS, популярный BIOS, который был портирован как на эмулированные машины Bochs, так и на машины с эмуляцией QEMU. Оба этих BIOSs реализуют большинство функций BIOS, которые можно было бы ожидать. Тем не менее, они довольно значительно отличаются по эксплуатации от коммерческих BIOS на реальных машинах.</p> <p>OVMF, популярная прошивка UEFI с открытым исходным кодом, была перенесена на эмулируемую машину QEMU (но не Bochs). Поскольку он реализует спецификацию UEFI, он ведет себя очень похоже на коммерческую прошивку UEFI на реальных машинах. (Сам OVMF построен с помощью TianoCore, но доступны готовые образы.)</p> <h3 id="загрузчик-bios-или-приложение-для-uefi"><a href="#загрузчик-bios-или-приложение-для-uefi" class="header-anchor">#</a> Загрузчик BIOS или приложение для UEFI?</h3> <p>Если вы ориентируетесь на устаревшие системы, для которых UEFI недоступен или ненадежен, вам следует разработать загрузчик для BIOS. Это требует глубокого знания 16-битной адресации и функций обратной совместимости процессора x86 или x86-64. Если вы ориентируетесь на современные системы, вам следует разработать UEFI-приложение. Многие прошивки UEFI могут быть сконфигурированы для эмуляции BIOS, но среди этих эмулируемых сред существует еще больше различий, чем среди реальных BIOS.</p> <h3 id="uefi-0-3-класса-и-csm"><a href="#uefi-0-3-класса-и-csm" class="header-anchor">#</a> UEFI 0-3 класса и CSM</h3> <p>ПК классифицируются как класс UEFI 0, 1, 2 или 3. Машина класса 0-это устаревшая система с BIOS, т.е. Вообще не система UEFI.</p> <p>Машина класса 1 - это система с UEFI, которая работает исключительно в режиме модуля поддержки совместимости (CSM). CSM - это спецификация того, как прошивка UEFI может эмулировать устаревший BIOS. Прошивка UEFI в режиме CSM загружает Legacy-загрузчики. Система UEFI класса 1 может вообще не декларировать поддержку UEFI, поскольку она не доступна загрузчику. Это только UEFI &quot;внутри&quot; BIOS.</p> <p>Машина класса 2 - это система UEFI, которая может запускать UEFI-приложения, но также включает в себя возможность запуска в режиме CSM. Большинство современных ПК - это машины класса UEFI 2. Иногда выбор для запуска UEFI-приложений против CSM - это тот или иной параметр в конфигурации BIOS, и в других случаях BIOS решит, какой из них использовать, после выбора загрузочного устройства и проверки того, у него Legacy-загрузчик или UEFI-приложение.</p> <p>Машина класса 3 - это система UEFI, которая не поддерживает CSM. Машины класса 3 UEFI запускают только UEFI-приложения и не реализуют CSM для обратной совместимости с Legacy-загрузчиками.</p> <h3 id="безопасная-загрузка-secure-boot"><a href="#безопасная-загрузка-secure-boot" class="header-anchor">#</a> Безопасная загрузка (Secure Boot)</h3> <p>Безопасная загрузка - это схема цифровой подписи для приложений UEFI, состоящая из четырех компонентов:</p> <ul><li>PK: Ключ платформы</li> <li>KEK: Ключ для обмена ключей</li> <li>db: Белый список</li> <li>dbx: Чёрный список</li></ul> <p>Прошивка UEFI, поддерживающая безопасную загрузку, всегда находится в одном из трех состояний:</p> <ul><li>Setup mode, Secure Boot off</li> <li>User mode, Secure Boot off</li> <li>User mode, Secure Boot on</li></ul> <p>В режиме настройки любое приложение UEFI может изменять или удалять PK, добавлять/удалять ключи из KEK, а также добавлять/удалять записи белого списка или черного списка из db или dbx.</p> <p>В пользовательском режиме, независимо от того, включена или выключена Безопасная загрузка:</p> <ul><li>PK может быть изменен или удален только приложением UEFI, у которого уже есть текущий PK.</li> <li>Ключи могут быть добавлены/удалены из KEK только приложением UEFI, имеющим PK.</li> <li>Записи белого списка и черного списка могут быть добавлены/удалены из db и dbx только приложением UEFI, у которого есть любой из ключей в KEK.</li></ul> <p>Наконец, в пользовательском режиме с включенной безопасной загрузкой приложения UEFI должны соответствовать одному из следующих четырех требований для запуска:</p> <ul><li>Подписано, с подписью в db, а не в dbx</li> <li>Подписано ключом в db, а не в dbx</li> <li>Подписано ключом в КЕК</li> <li>Не подписано, но хэш приложения находится в db, а не в dbx</li></ul> <p>Обратите внимание, что приложения UEFI не подписываются PK, если только PK также не находится в KEK.</p> <p>Не все прошивки UEFI поддерживают безопасную загрузку, хотя это является обязательным требованием для Windows 8. Некоторые прошивки UEFI поддерживают безопасную загрузку, и нет возможности отключить их, что создает проблему для независимых разработчиков, которые не имеют доступа к PK или любому из ключей в KEK и, следовательно, не могут установить свой собственный ключ или подпись приложения или хэш в базу данных белого списка. Независимые разработчики должны разрабатывать используя системы, которые либо не поддерживают безопасную загрузку, либо имеют возможность отключить безопасную загрузку.</p> <h3 id="как-использовать-uefi"><a href="#как-использовать-uefi" class="header-anchor">#</a> Как использовать UEFI</h3> <p>Традиционные операционные системы, такие как Windows и Linux, имеют существующую программную архитектуру и большую базу кода для выполнения конфигурации системы и обнаружения устройств. С их сложными уровнями абстракции они не получают прямой выгоды от UEFI. В результате их загрузчики UEFI мало что делают, кроме подготовки среды для их запуска.</p> <p>Независимый разработчик может найти больше пользы в использовании UEFI для написания полнофункциональных приложений UEFI, а не в том, чтобы рассматривать UEFI как временную среду запуска, которую можно выбросить во время процесса загрузки. В отличие от устаревших загрузчиков, которые обычно взаимодействуют с BIOS только для запуска ОС, приложение UEFI может реализовать сложное поведение с помощью UEFI. Другими словами, независимый разработчик не должен спешить покидать &quot;UEFI-land&quot;.</p> <p>Хорошей отправной точкой является написание приложения UEFI, которое использует системную таблицу для извлечения карты памяти и использует протокол &quot;File&quot; для чтения файлов с дисков в формате FAT. Следующим шагом может быть использование системной таблицы для поиска таблиц ACPI.</p> <h2 id="разработка-с-posix-uefi"><a href="#разработка-с-posix-uefi" class="header-anchor">#</a> Разработка с POSIX-UEFI</h2> <p>Простой способ компиляции приложений EFI в Linux (или любой другой системе, совместимой с POSIX) - это POSIX-UEFI. Он не только предоставляет хорошо известный libc-подобный API для вашего приложения EFI, но и генерирует Makefile, который поможет обнаружить и настроить набор инструментов для вас. Работает как с GNU gcc, так и с LLVM CLang.</p> <p>Он имеет POSIX-измененные типы (например, uintn_t вместо UINTN), и ему не нужны стандартные заголовки EFI. Но если вы установите их из EDK2 или GNU-EFI, вы также сможете безопасно включить их, конфликтов имен не будет. Тем не менее, эти интерфейсы правильно определены, и все поля имеют точно такое же имя, как и в EDK2, так что это большое преимущество перед GNU-EFI.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>ST<span class="token operator">-&gt;</span>ConOut<span class="token operator">-&gt;</span><span class="token function">OutputString</span><span class="token punctuation">(</span>ST<span class="token operator">-&gt;</span>ConOut<span class="token punctuation">,</span> L<span class="token string">&quot;Hi!\r\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Типичный &quot;Hello World&quot; на UEFI выглядит примерно так:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;uefi.h&gt;</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>А Makefile выглядит вот так:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>TARGET <span class="token operator">=</span> main<span class="token punctuation">.</span>efi
include uefi<span class="token operator">/</span>Makefile
</code></pre></div><p>Теперь просто запусти сборку командой <strong>make</strong> и на выходе получишь файл main.efi</p> <h2 id="разработка-с-gnu-efi"><a href="#разработка-с-gnu-efi" class="header-anchor">#</a> Разработка с GNU-EFI</h2> <p>GNU-EFI можно использовать для разработки как 32-разрядных, так и 64-разрядных приложений UEFI. В этом разделе будут рассмотрены только 64-разрядные приложения UEFI и предполагается, что сама среда разработки работает в системе x86_64, поэтому кросс-компилятор не требуется.</p> <p>GNU-EFI включает в себя следующие вещи:</p> <ul><li><strong>crt0-efi-x86_64.o</strong>: CRT0 (код инициализации среды выполнения C), обеспечивающий точку входа, которую микропрограмма UEFI вызовет при запуске приложения, которое, в свою очередь, вызовет функцию &quot;efi_main&quot;, записанную разработчиком.</li> <li><strong>libgnuefi.a</strong>: Библиотека, содержащая одну функцию (_relocate), которая используется CRT0.</li> <li><strong>elf_x86_64_efi.lds</strong>: Скрипт компоновщика, используемый для связывания двоичных файлов ELF в приложения UEFI.</li> <li><strong>efi.h</strong> и другие заголовки: Удобные заголовки, которые предоставляют структуры, типы и константы, улучшают читаемость при доступе к системной таблице и другим ресурсам UEFI.</li> <li><strong>libefi.a</strong>: Библиотека, содержащая удобные функции, такие как вычисление CRC, вычисление длины строки и простая печать текста.</li> <li><strong>efilib.h</strong>: Заголовок для libefi.a.</li></ul> <p>Как минимум, 64-разрядное приложение UEFI должно будет связываться с <strong>crt0-efi-x86_64.o</strong> и <strong>libgnuefi.a</strong> с помощью скрипта компоновщика <strong>elf_x86_64_efi.lds</strong>. Скорее всего, вы захотите также использовать предоставленные заголовки и библиотеки удобства, и в этом разделе предполагается, что и в дальнейшем.</p> <p>Типичный &quot;Hello World&quot; на UEFI выглядит примерно так:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;efi.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;efilib.h&gt;</span></span>
 
EFI_STATUS 
EFIAPI 
<span class="token function">efi_main</span> <span class="token punctuation">(</span>EFI_HANDLE ImageHandle<span class="token punctuation">,</span> EFI_SYSTEM_TABLE <span class="token operator">*</span>SystemTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">InitializeLib</span><span class="token punctuation">(</span>ImageHandle<span class="token punctuation">,</span> SystemTable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Print</span><span class="token punctuation">(</span>L<span class="token string">&quot;Hello, world!\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> EFI_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Несколько заметок:</p> <ul><li>efi.h включен, поэтому мы можем использовать такие типы, как EFI_STATUS, EFI_HANDLE и EFI_SYSTEM_TABLE.</li> <li>При создании 32-разрядного приложения UEFI EFIAPI пуст; GCC скомпилирует функцию &quot;efi_main&quot;, используя стандартные вызовы C. При создании 64-разрядного приложения UEFI EFIAPI расширяется до &quot;<strong>attribute</strong>((ms_abi))&quot;, и GCC скомпилирует функцию &quot;efi_main&quot;, используя стандарт о вызовах Microsoft x64, как указано в UEFI. Только функции, которые будут вызываться непосредственно из UEFI (включая main, но также и обратные вызовы), должны использовать стандарт о вызовах UEFI.</li> <li>&quot;InitializeLib&quot; и &quot;Print&quot; - это удобные функции, предоставляемые libefi.a с прототипами в efilib.h. &quot;InitializeLib&quot; позволяет libefi.a хранить ссылку на ImageHandle и SystemTable, предоставляемые BIOS. &quot;Print&quot; использует эти сохраненные ссылки для вывода строки, обращаясь к функциям, предоставляемым UEFI в памяти. (Позже мы увидим, как найти и вызвать функции, предоставляемые UEFI, вручную.)</li></ul> <p>Программа скомпилированна и слинкована как показано ниже:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>gcc main.c                             <span class="token punctuation">\</span>
      -c                                 <span class="token punctuation">\</span>
      -fno-stack-protector               <span class="token punctuation">\</span>
      -fpic                              <span class="token punctuation">\</span>
      -fshort-wchar                      <span class="token punctuation">\</span>
      -mno-red-zone                      <span class="token punctuation">\</span>
      -I /path/to/gnu-efi/headers        <span class="token punctuation">\</span>
      -I /path/to/gnu-efi/headers/x86_64 <span class="token punctuation">\</span>
      -DEFI_FUNCTION_WRAPPER             <span class="token punctuation">\</span>
      -o main.o

ld main.o                         <span class="token punctuation">\</span>
     /path/to/crt0-efi-x86_64.o     <span class="token punctuation">\</span>
     -nostdlib                      <span class="token punctuation">\</span>
     -znocombreloc                  <span class="token punctuation">\</span>
     -T /path/to/elf_x86_64_efi.lds <span class="token punctuation">\</span>
     -shared                        <span class="token punctuation">\</span>
     -Bsymbolic                     <span class="token punctuation">\</span>
     -L /path/to/libs               <span class="token punctuation">\</span>
     -l:libgnuefi.a                 <span class="token punctuation">\</span>
     -l:libefi.a                    <span class="token punctuation">\</span>
     -o main.so

objcopy -j .text                <span class="token punctuation">\</span>
          -j .sdata               <span class="token punctuation">\</span>
          -j .data                <span class="token punctuation">\</span>
          -j .dynamic             <span class="token punctuation">\</span>
          -j .dynsym              <span class="token punctuation">\</span>
          -j .rel                 <span class="token punctuation">\</span>
          -j .rela                <span class="token punctuation">\</span>
          -j .reloc               <span class="token punctuation">\</span>
          --target<span class="token operator">=</span>efi-app-x86_64 <span class="token punctuation">\</span>
          main.so                 <span class="token punctuation">\</span>
          main.efi
</code></pre></div><p>В результате вы получите файл main.efi, которые будет весить 44 КБ.</p> <h2 id="эмуляция-с-qemu-и-ovmf"><a href="#эмуляция-с-qemu-и-ovmf" class="header-anchor">#</a> Эмуляция с QEMU и OVMF</h2> <p>Любой последней версии QEMU с последней версией OVMF будет достаточно для запуска приложения UEFI. Исполняемые файлы QEMU доступны для многих платформ, а образ OVMF (OVMF.fd) можно найти на веб-сайте TianoCore. QEMU (без загрузочного диска) можно вызвать, как показано ниже. Чтобы предотвратить попытку загрузки по PXE (сети) в последних версиях QEMU при отсутствии загрузочного диска, используйте <strong>-net none</strong>.</p> <p>Рекомендуется использовать OVMF (для QEMU 1.6 или новее) с параметром <strong>pflash</strong>. В приведенных ниже инструкциях предполагается, что у вас есть образ OVMF, разделённый на отдельные разделы CODE и VARS.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>qemu-system-x86_64 -cpu qemu64 <span class="token punctuation">\</span>
  -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,unit<span class="token operator">=</span><span class="token number">0</span>,file<span class="token operator">=</span>path_to_OVMF_CODE.fd,readonly<span class="token operator">=</span>on <span class="token punctuation">\</span>
  -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,unit<span class="token operator">=</span><span class="token number">1</span>,file<span class="token operator">=</span>path_to_OVMF_VARS.fd <span class="token punctuation">\</span>
  -net none
</code></pre></div><p>Если вы предпочитаете работать через терминал или через SSH/telnet, вы можете запустить QEMU без графической поддержки, используя флаг <strong>-nographic</strong>.</p> <p>Если OVMF не найдет загрузочный диск с правильно названным приложением UEFI (подробнее об этом позже), он попадет в оболочку UEFI.</p> <p><img src="/OVMF_shell.png" alt="Оболочка UEFI"></p> <p>Вы можете просмотреть список доступных команд с помощью команды <strong>help</strong>.</p> <h3 id="создание-образа-диска"><a href="#создание-образа-диска" class="header-anchor">#</a> Создание образа диска</h3> <p>Чтобы запустить приложение UEFI, вам нужно будет создать образ диска и представить его в QEMU. Прошивка UEFI ожидает, что приложения UEFI будут храниться в файловой системе FAT12, FAT16 или FAT32 (называемой системным разделом EFI) на диске с разделением GPT. Многие прошивки поддерживают только FAT32, так что это то, что вы захотите использовать. В зависимости от вашей платформы существует несколько различных способов создания образа диска, содержащего ваше приложение UEFI, но все они начинаются с создания обнуленного файла образа диска. Минимальный размер раздела FAT32 составляет 33 548 800 байт, плюс вам понадобится место для первичной и вторичной таблиц GPT, а также некоторое свободное пространство, чтобы раздел можно было правильно выровнять. В этих примерах мы создадим образ диска размером 48 000 000 байт (93750 512-байтовых секторов или 48 МБ).</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>/path/to/uefi.img <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">93750</span>
</code></pre></div><h4 id="приложение-uefi-run"><a href="#приложение-uefi-run" class="header-anchor">#</a> Приложение uefi-run</h4> <p>Приложение uefi-run полезно для быстрого тестирования. Оно создает временный образ FAT, содержащий ваше приложение EFI, и запускает qemu.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>uefi-run -b /path/to/OVMF.fd -q /path/to/qemu app.efi -- <span class="token operator">&lt;</span>дополнительные аргументы для QEMU<span class="token operator">&gt;</span>
</code></pre></div><p>uefi-run в настоящее время не собран для какого-либо дистрибутива. Вы можете установить его с помощью cargo (менеджер пакетов Rust) (&quot;cargo install uefi-run&quot;).</p> <h4 id="linux-необходим-root-доступ"><a href="#linux-необходим-root-доступ" class="header-anchor">#</a> Linux, необходим root-доступ</h4> <p>Этот подход требует root-доступ и использует gdisk, losetup и mkdosfs.</p> <p>Во-первых, используйте gdisk для создания таблицы разделов GPT с одним системным разделом EFI.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>gdisk /path/to/uefi.img
GPT <span class="token function">fdisk</span> <span class="token punctuation">(</span>gdisk<span class="token punctuation">)</span> version <span class="token number">0.8</span>.10
 
Partition table scan:
  MBR: not present
  BSD: not present
  APM: not present
  GPT: not present
 
Creating new GPT entries.
 
Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: o
This option deletes all partitions and creates a new protective MBR.
Proceed? <span class="token punctuation">(</span>Y/N<span class="token punctuation">)</span>: y
 
Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-128, default <span class="token number">1</span><span class="token punctuation">)</span>: <span class="token number">1</span>
First sector <span class="token punctuation">(</span><span class="token number">34</span>-93716, default <span class="token operator">=</span> <span class="token number">2048</span><span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>: <span class="token number">2048</span>
Last sector <span class="token punctuation">(</span><span class="token number">2048</span>-93716, default <span class="token operator">=</span> <span class="token number">93716</span><span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>: <span class="token number">93716</span>
Current <span class="token builtin class-name">type</span> is <span class="token string">'Linux filesystem'</span>
Hex code or GUID <span class="token punctuation">(</span>L to show codes, Enter <span class="token operator">=</span> <span class="token number">8300</span><span class="token punctuation">)</span>: ef00
Changed <span class="token builtin class-name">type</span> of partition to <span class="token string">'EFI System'</span>
 
Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
 
Final checks complete. About to <span class="token function">write</span> GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS<span class="token operator">!</span><span class="token operator">!</span>
 
Do you want to proceed? <span class="token punctuation">(</span>Y/N<span class="token punctuation">)</span>: y
OK<span class="token punctuation">;</span> writing new GUID partition table <span class="token punctuation">(</span>GPT<span class="token punctuation">)</span> to uefi.img.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot.
The operation has completed successfully.
</code></pre></div><p>Теперь у вас есть образ диска с таблицей разделов GUID и неформатированный раздел EFI, начиная с сектора 2048. Если вы не отклонились от команд, показанных выше, образ диска будет использовать 512-байтовые секторы, поэтому раздел EFI начинается с байта 1 048 576 и имеет длину 46 934 528 байт.</p> <p>Используйте losetup для представления раздела в Linux.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>losetup --offset <span class="token number">1048576</span> --sizelimit <span class="token number">46934528</span> /dev/loop0 /path/to/uefi.img
</code></pre></div><p>(Если /dev/loop0 уже используется, вам нужно будет выбрать другое loopback-устройство.)</p> <p>Отформатируйте раздел в FAT32 с помощью mkdosfs.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>mkdosfs -F <span class="token number">32</span> /dev/loop0
</code></pre></div><p>Теперь раздел можно смонтировать, чтобы мы могли копировать в него файлы. В этом примере мы используем каталог &quot;/mnt&quot;, но вы также можете создать локальный каталог для временного использования.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mount</span> /dev/loop0 /mnt
</code></pre></div><p>Скопируйте все приложения UEFI, которые вы хотите протестировать, в файловую систему.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> /path/to/main.efi /mnt/
</code></pre></div><p>Наконец, размонтируйте раздел и освободите loopback-устройство.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">umount</span> /mnt
losetup -d /dev/loop0
</code></pre></div><p>uefi.img теперь представляет собой образ диска, содержащий первичные и вторичные таблицы GPT, содержащие один раздел типа EFI, содержащий файловую систему FAT32, содержащую одно или несколько приложений UEFI.</p> <h4 id="linux-без-root-доступа"><a href="#linux-без-root-доступа" class="header-anchor">#</a> Linux, без root-доступа</h4> <p>Этот подход использует parted, mformat, mcopy и может выполняться с правами пользователя.</p> <p>Во-первых, используйте parted для создания первичных и вторичных заголовков GPT, а также одного раздела EFI, охватывающего тот же диапазон, что и описанный выше подход.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">parted</span> /path/to/uefi.img -s -a minimal mklabel gpt
<span class="token function">parted</span> /path/to/uefi.img -s -a minimal mkpart EFI FAT16 2048s 93716s
<span class="token function">parted</span> /path/to/uefi.img -s -a minimal toggle <span class="token number">1</span> boot
</code></pre></div><p>Теперь создайте новый временный файл образа, который будет содержать данные раздела EFI, и используйте mformat для форматирования его с помощью FAT16.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>/tmp/part.img <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">91669</span>
mformat -i /tmp/part.img -h <span class="token number">32</span> -t <span class="token number">32</span> -n <span class="token number">64</span> -c <span class="token number">1</span>
</code></pre></div><p>Используйте mcopy для копирования любых приложений UEFI, которые вы хотите протестировать, в файловую систему.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>mcopy -i /tmp/part.img /path/to/main.efi ::
</code></pre></div><p>Наконец, запишите образ раздела в образ основного диска.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/tmp/part.img <span class="token assign-left variable">of</span><span class="token operator">=</span>/path/to/uefi.img <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">91669</span> <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token number">2048</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc
</code></pre></div><p>uefi.img теперь представляет собой образ диска, содержащий первичные и вторичные таблицы GPT, содержащие один раздел типа EFI, содержащий файловую систему FAT16, содержащую одно или несколько приложений UEFI.</p> <h4 id="freebsd-требуется-root-доступ"><a href="#freebsd-требуется-root-доступ" class="header-anchor">#</a> FreeBSD, требуется root-доступ</h4> <p>Этот подход требует привилегий root и использует mdconfig, gpart, newfs_msdos и mount_msdosfs.</p> <p>Сначала создайте узел устройства, который представляет обнуленный образ диска в виде блочного устройства. Это позволит нам работать над ним, используя стандартные инструменты разделения и форматирования.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ mdconfig -f /path/to/uefi.img
md0
</code></pre></div><p>В этом примере новым блочным устройством является md0. Теперь создайте пустые первичные и вторичные таблицы GPT на устройстве.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ gpart create -s GPT md0
md0 created
</code></pre></div><p>Теперь мы можем добавить раздел на диск. Мы укажем раздел &quot;EFI&quot;, что просто означает, что GPT установит GUID этого раздела для специального типа &quot;EFI&quot;. Не все BIOS требуют этого, и раздел по-прежнему можно будет монтировать и просматривать в обычном режиме в Linux, FreeBSD и Windows.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ gpart <span class="token function">add</span> -t efi md0
md0p1 added
</code></pre></div><p>Затем создайте файловую систему FAT16 на новом разделе. Вы можете указать различные параметры для файловой системы, если хотите, но это не обязательно. В идеале вы бы создали раздел FAT32 для лучшей совместимости прошивки, но FreeBSD, похоже, создает разделы FAT32, которые OVMF не может прочитать.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ newfs_msdos -F <span class="token number">16</span> md0p1
newfs_msdos: trim <span class="token number">2</span> sectors to adjust to a multiple of <span class="token number">9</span>
/dev/md2p1: <span class="token number">93552</span> sectors <span class="token keyword">in</span> <span class="token number">11694</span> FAT16 clusters <span class="token punctuation">(</span><span class="token number">4096</span> bytes/cluster<span class="token punctuation">)</span>
<span class="token assign-left variable">BytesPerSec</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">SecPerClust</span><span class="token operator">=</span><span class="token number">8</span> <span class="token assign-left variable">ResSectors</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">FATs</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">RootDirEnts</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">Media</span><span class="token operator">=</span>0xf0 <span class="token assign-left variable">FATsecs</span><span class="token operator">=</span><span class="token number">46</span> <span class="token assign-left variable">SecPerTrack</span><span class="token operator">=</span><span class="token number">9</span> <span class="token assign-left variable">Heads</span><span class="token operator">=</span><span class="token number">16</span> <span class="token assign-left variable">HiddenSecs</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">HugeSectors</span><span class="token operator">=</span><span class="token number">93681</span>
</code></pre></div><p>Теперь раздел можно смонтировать, чтобы мы могли копировать в него файлы. В этом примере мы используем каталог /mnt, но вы также можете создать локальный каталог для временного использования.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>mount_msdosfs /dev/md0p1 /mnt
</code></pre></div><p>Скопируйте все приложения UEFI, которые вы хотите протестировать, в файловую систему.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> /path/to/main.efi /mnt/
</code></pre></div><p>Наконец, размонтируйте раздел и освободите устройство.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">umount</span> /mnt
$ mdconfig -d -u md0
</code></pre></div><p>uefi.img теперь представляет собой образ диска, содержащий первичные и вторичные таблицы GPT, содержащие один раздел типа EFI, содержащий файловую систему FAT16, содержащую одно или несколько приложений UEFI.</p> <h4 id="macos-не-требуется-root-доступ"><a href="#macos-не-требуется-root-доступ" class="header-anchor">#</a> macOS, не требуется root-доступ</h4> <p>В Mac OS есть один инструмент (hdiutil), который одновременно создает образ диска и копирует файлы.</p> <p>Допустим, вы создаете UEFI для x86_64. По определению имя файла должно быть BOOTX64.EFI и этот файл должны находиться в папке /EFI/BOOT.</p> <p>Во-первых, давайте создадим временную папку, которая будет содержать все файлы и папки, необходимые для загрузки UEFI.</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> -p diskImage/EFI/BOOT
</code></pre></div><p>Во-вторых, давайте скопируем приложение в нужную директорию:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cp</span> bootx64.efi diskImage/EFI/BOOT/BOOTX64.EFI
</code></pre></div><p>Наконец, давайте создадим образ диска, разделенный GPT, отформатированный с помощью fat32 (-fs fat32), при необходимости переопределим файл назначения (-ov), определим размер диска (-размер 48m), имя тома (-volname NEWOS), формат файла, в котором будет закодирован диск (-формат UDTO - тот же, что используется для DVD/CD), и исходную папку, содержащую файлы, которые будут скопированы на новый диск:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hdiutil create -fs fat32 -ov -size 48m -volname NEWOS -format UDTO -srcfolder diskImage uefi.cdr
</code></pre></div><p>uefi.cdr готов к использованию в QEMU.</p> <h3 id="запуск-uefi-приложении"><a href="#запуск-uefi-приложении" class="header-anchor">#</a> Запуск UEFI-приложений</h3> <p>Как только ваш образ диска будет готов, вы можете вызвать QEMU, как показано ниже.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>qemu-system-x86_64 -cpu qemu64 -bios /path/to/OVMF.fd -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>uefi.disk,if<span class="token operator">=</span>ide
</code></pre></div><p>Когда OVMF попадет в оболочку UEFI, вы увидите дополнительную запись в &quot;Mapping table&quot; с пометкой &quot;FS0&quot;. Это указывает на то, что прошивка обнаружила диск, обнаружила раздел и смогла смонтировать файловую систему. Вы можете изучить файловую систему, переключившись на нее с помощью синтаксиса в стиле DOS &quot;FS0:&quot;, как показано ниже.</p> <p><img src="/OVMF_browse_fs.png" alt="Обзор файловой системы"></p> <p>Вы можете запустить приложение UEFI, введя его имя.</p> <p><img src="/OVMF_run_app.png" alt="Запуск приложения"></p> <p>Обратите внимание, что оболочка UEFI возобновилась после завершения работы приложения. Конечно, если бы это был правильный загрузчик, он никогда бы не возобновился, а скорее запустил ОС.</p> <p>Некоторые коммерческие прошивки UEFI предоставляют оболочки UEFI или возможность запуска выбранных пользователем приложений UEFI, таких как прошивка, поставляемая с линейкой ноутбуков HP EliteBook. Однако большинство из них не предоставляют эту функциональность конечному пользователю.</p> <h3 id="отладка"><a href="#отладка" class="header-anchor">#</a> Отладка</h3> <p>OVMF может быть построен в режиме отладки, и он будет выводить сообщения журнала на порт ввода-вывода <strong>0x402</strong>. Вы можете использовать некоторые флаги, подобные приведенным ниже, для захвата выходных данных.</p> <div class="language-bash extra-class"><pre class="language-bash"><code>-debugcon file:uefi_debug.log -global isa-debugcon.iobase<span class="token operator">=</span>0x402
</code></pre></div><p>Обратите внимание, что релизные сборки не будут выводить отладочные сообщения или будут иметь уменьшенный вывод.</p> <h2 id="запуск-на-реальном-железе"><a href="#запуск-на-реальном-железе" class="header-anchor">#</a> Запуск на реальном железе</h2> <h3 id="nvram-переменные"><a href="#nvram-переменные" class="header-anchor">#</a> NVRAM переменные</h3> <p>Прошивка UEFI представит большинство своих параметров конфигурации через текстовое или графическое меню конфигурации, как и BIOS. Выбор, сделанный в этих меню, сохраняется в чипе NVRAM между перезагрузками. Однако, в отличие от BIOS, разработчик прошивки имеет возможность предоставить некоторые или все эти &quot;переменные NVRAM&quot; операционной системе и конечному пользователю с помощью удобных функций, размещенных в оперативной памяти прошивкой при загрузке.</p> <p>Модуль ядра Linux efivarfs будет использовать эти функции для перечисления переменных NVRAM в файле /sys/firmware/efi/efivars. Переменные NVRAM также могут быть сброшены из самой оболочки UEFI с помощью команды dmpstore. Порядок загрузки устройства всегда доступен через переменные NVRAM.</p> <h3 id="загружаемые-uefi-приложения"><a href="#загружаемые-uefi-приложения" class="header-anchor">#</a> Загружаемые UEFI-приложения</h3> <p>Переменные NVRAM порядка загрузки определяют, где прошивка будет искать приложения UEFI, которые будут запущены при загрузке. Хотя это можно изменить (например, установщик ОС может настроить загрузочную запись для жесткого диска, на который она была установлена), прошивка обычно ищет приложение UEFI с именем &quot;BOOT.efi&quot; (для 32-разрядных приложений) или &quot;BOOTX64.efi&quot; (для 64-разрядных приложений), хранящееся в пути &quot;/EFI/BOOT&quot; в файловой системе загрузочного устройства. Это путь и имя по умолчанию для OVMF.</p> <p>В отличие от приложения UEFI, запущенного из оболочки, если загрузочное приложение UEFI возвращает в BIOS, оно продолжит поиск других загрузочных устройств.</p> <h3 id="открытая-функциональность"><a href="#открытая-функциональность" class="header-anchor">#</a> Открытая функциональность</h3> <p>Реальные ПК различаются по объему возможностей UEFI, которые они предоставляют пользователю. Например, даже машина класса 3 может не упоминать UEFI в своей конфигурации BIOS и не предлагать оболочку UEFI. Кроме того, некоторые поставщики BIOS делают свои экраны конфигурации прошивки UEFI идентичными экранам конфигурации BIOS. Машины класса 2 могут представлять несколько запутанные меню загрузки и параметры конфигурации. Например, один производитель ноутбуков включает параметр конфигурации для включения/отключения UEFI (т.е. Переключения между поведением UEFI и CSM) под названием &quot;OS: Windows 8&quot;. Другой ноутбук, если ему не удастся найти загрузочное приложение UEFI на выбранном загрузочном устройстве (или если это приложение вернет состояние, отличное от EFI_SUCCESS), вернется к поведению CSM, а затем пожалуется, что на диске поврежден MBR.</p> <p>Чтобы упростить тестирование на реальном оборудовании, вы можете установить загрузочное приложение UEFI на внутренний жесткий диск системы, которое предоставляет меню загрузки, например rEFInd. Это также может быть удобно для сценариев с несколькими загрузками.</p> <h3 id="разработчики-прошивки-для-пк"><a href="#разработчики-прошивки-для-пк" class="header-anchor">#</a> Разработчики прошивки для ПК</h3> <p>На платформах x86 и x86-64 следующие разработчики BIOS предлагают прошивку UEFI:</p> <ul><li>AMI (Aptio).</li> <li>Phoenix (SecureCore, TrustedCore, AwardCore).</li> <li>Insyde (InsydeH20).</li></ul> <h3 id="системы-apple"><a href="#системы-apple" class="header-anchor">#</a> Системы Apple</h3> <p>Системы Apple реализуют EFI 1.0, в отличие от UEFI, с тем отличием, что приложения UEFI загружаются из файловых систем HFS+ вместо FAT12/16/32. Кроме того, эти приложения UEFI должны быть &quot;подписаны&quot; (либо непосредственно, либо путем нахождения в подписанном каталоге) для загрузки. Blessing устанавливает флаги в файловой системе HFS+, которые проверяет прошивка Apple перед загрузкой приложения. Пакет hfsutils с открытым исходным кодом включает поддержку файлов в файловых системах HFS, но не каталогов и не HFS+.</p> <h2 id="uefi-приложения-в-деталях"><a href="#uefi-приложения-в-деталях" class="header-anchor">#</a> UEFI-приложения в деталях</h2> <h3 id="бинарныи-формат"><a href="#бинарныи-формат" class="header-anchor">#</a> Бинарный формат</h3> <p>Исполняемые файлы UEFI-это обычные образы PE32 / PE32+ (Windows x32 / x64) с определенной подсистемой. Каждое приложение UEFI в основном представляет собой исполняемый файл Windows (или DLL) без таблиц символов.</p> <p><strong>Типы UEFI-образов</strong></p> <table><thead><tr><th>Тип</th> <th>Описание</th> <th>Подсистема</th></tr></thead> <tbody><tr><td>Приложения</td> <td>Загрузчики ОС и другие утилиты.</td> <td>10</td></tr> <tr><td>Драйвер службы загрузки</td> <td>Драйверы, используемые встроенным ПО при загрузке (например, драйверы дисков, сетевые драйверы).</td> <td>11</td></tr> <tr><td>Драйвер среды выполнения</td> <td>Драйверы, которые могут оставаться загруженными даже после загрузки ОС и выхода из службы загрузки.</td> <td>11</td></tr></tbody></table> <p>Образы UEFI также должны указывать тип машинного кода, который они содержат. Загрузчик UEFI откажется загружать несовместимый образ.</p> <p><strong>Типы машин</strong></p> <table><thead><tr><th>Название</th> <th>Значение</th></tr></thead> <tbody><tr><td>x86</td> <td>0x014c</td></tr> <tr><td>x86_64</td> <td>0x8664</td></tr> <tr><td>Itanium x64</td> <td>0x0200</td></tr> <tr><td>UEFI Byte Code</td> <td>0x0EBC</td></tr> <tr><td>ARM</td> <td>0x01C2</td></tr> <tr><td>AArch (ARM x64)</td> <td>0xAA64</td></tr> <tr><td>RISC-V x32</td> <td>0x5032</td></tr> <tr><td>RISC-V x64</td> <td>0x5064</td></tr> <tr><td>RISC-V x128</td> <td>0x5128</td></tr></tbody></table> <p>ARM означает, что вы можете использовать инструкции Thumb/Thumb 2, но интерфейсы UEFI находятся в режиме ARM.</p> <h4 id="инициализация"><a href="#инициализация" class="header-anchor">#</a> Инициализация</h4> <p>Приложения должны либо загрузить ОС и выйти из служб загрузки, либо вернуться из основной функции (в этом случае загрузчик будет искать следующее загружаемое приложение).</p> <p>Драйверы должны инициализироваться, а затем возвращать 0 при успешном выполнении или код ошибки. Компьютер может не загрузиться, если не загрузится необходимый драйвер.</p> <h4 id="память"><a href="#память" class="header-anchor">#</a> Память</h4> <p>Карта памяти, возвращаемая UEFI, будет отмечать области памяти, используемые драйверами.</p> <p>После завершения загрузки ОС ядру разрешается повторно использовать память, в которую был загружен загрузчик.</p> <p>Типы памяти - <strong>Efi{Loader/BootServices/RuntimeServices}{Code/Data}</strong>.</p> <p>После выхода из служб загрузки вы можете повторно использовать любую память, доступную только для чтения, которую использовали драйверы загрузки.</p> <p>Однако память, используемая драйверами среды выполнения, никогда не должна быть затронута - драйверы среды выполнения остаются активными и загруженными до тех пор, пока работает компьютер.</p> <p>Один из способов увидеть разбивку PE-файла, содержащего приложение UEFI, - это</p> <div class="language-bash extra-class"><pre class="language-bash"><code>objdump --all-headers /path/to/main.efi
</code></pre></div><p>Его выход довольно длинный. Среди прочего, он показывает подсистему, то есть тип образа UEFI, упомянутый ранее.</p> <h3 id="соглашение-о-вызовах"><a href="#соглашение-о-вызовах" class="header-anchor">#</a> Соглашение о вызовах</h3> <p>UEFI определяет следующие соглашения о вызовах:</p> <ul><li><strong>cdecl</strong> для x86 UEFI-функций</li> <li><strong>Microsoft's 64-bit calling convention</strong> для x86-64 UEFI-функций</li> <li><strong>SMC</strong> для ARM UEFI-функций</li></ul> <p>Это оказывает два влияния на разработчиков приложений UEFI:</p> <ul><li>Основная точка входа приложения UEFI должна ожидать вызова с соответствующим соглашением о вызове.</li> <li>Любые функции, предоставляемые UEFI, которые вызывает приложение UEFI, должны вызываться с соответствующим соглашением о вызовах.</li></ul> <p>Обратите внимание, что функции, строго внутренние для приложения, могут использовать любое соглашение о вызовах, которое выберет разработчик.</p> <h4 id="posix-uefi-gnu-efi-and-gcc"><a href="#posix-uefi-gnu-efi-and-gcc" class="header-anchor">#</a> POSIX-UEFI, GNU-EFI and GCC</h4> <p>cdecl - это стандартное соглашение о вызовах, используемое GCC, поэтому для записи основной точки входа или вызова функций UEFI в приложении UEFI x86, разработанном с использованием GNU-EFI, не требуется никаких специальных атрибутов или модификаторов. Однако для x86-64 функция точки входа должна быть объявлена с модификатором &quot;<em><strong>attribute</strong></em>((ms_abi))&quot;, и все вызовы функций, предоставляемых UEFI, должны выполняться через функцию &quot;uefi_call_wrapper&quot;. Этот преобразователь вызывается с помощью cdecl, но затем преобразуется в соглашение о вызове Microsoft x86-64 перед вызовом запрошенной функции UEFI. Это необходимо, поскольку более старые версии GCC не поддерживают указание соглашений о вызовах для указателей функций.</p> <p>Для POSIX-UEFI, который также использует GCC, ваша точка входа выглядит как стандартная main(), и никакого специального ABI не требуется. Кроме того, среда сборки заботится о флагах компилятора для вас, поэтому вы можете просто вызывать функции UEFI без &quot;uefi_call_wrapper&quot;, независимо от того, используете ли вы gcc или другой кросс-компилятор.</p> <p>Для удобства разработчиков как POSIX-UEFI, так и GNU-EFI предоставляют макрос &quot;EFIAPI&quot;, который расширяется до &quot;cdecl&quot; при таргетинге на x86 и &quot;<strong>attribute</strong>(ms_abi))&quot; при таргетинге на x86-64. Кроме того, функция &quot;uefi_call_wrapper&quot; просто передаст вызов на x86. Это позволяет использовать один и тот же исходный код для x86 и x86-64. Например, следующая основная функция будет компилироваться с правильным соглашением о вызове как на x86, так и на x86-64, и вызов через функцию &quot;uefi_call_wrapper&quot; выберет правильное соглашение о вызове для использования при вызове функции UEFI (в данном случае вывод строки).</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>EFI_STATUS EFIAPI <span class="token function">efi_main</span><span class="token punctuation">(</span>EFI_HANDLE ImageHandle<span class="token punctuation">,</span> EFI_SYSTEM_TABLE <span class="token operator">*</span>SystemTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  EFI_STATUS status <span class="token operator">=</span> <span class="token function">uefi_call_wrapper</span><span class="token punctuation">(</span>SystemTable<span class="token operator">-&gt;</span>ConOut<span class="token operator">-&gt;</span>OutputString<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> SystemTable<span class="token operator">-&gt;</span>ConOut<span class="token punctuation">,</span> L<span class="token string">&quot;Hello, World!\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> status<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="биндинги-языка"><a href="#биндинги-языка" class="header-anchor">#</a> Биндинги языка</h3> <p>Приложения UEFI обычно пишутся на языке C, хотя биндинги могут быть написаны для любого другого языка, который компилируется в машинный код. Assembler также является опцией; для FASM доступен файл uefi.inc, который позволяет писать приложения UEFI, как показано ниже.</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>format pe64 dll efi
entry main
 
section <span class="token string">'.text'</span> code executable readable
 
include <span class="token string">'uefi.inc'</span>
 
<span class="token label function">main:</span>
    <span class="token comment">; Инициализация библиотеки UEFI</span>
    InitializeLib
    jc @f
 
    <span class="token comment">; Вызов UEFI-функции для вывода на экран</span>
    uefi_call_wrapper ConOut, OutputString, ConOut, _hello
 
@@: mov <span class="token register variable">eax</span>, EFI_SUCCESS
    retn
 
section <span class="token string">'.data'</span> data readable writeable
 
_hello                                  du <span class="token string">'Hello World'</span>,<span class="token number">13</span>,<span class="token number">10</span>,<span class="token number">0</span>
 
section <span class="token string">'.reloc'</span> fixups data discardable
</code></pre></div><p>Поскольку приложение UEFI содержит обычный машинный код x86 или x86-64, inline assembly также является опцией в компиляторах, которые ее поддерживают.</p> <h3 id="efi-баиткод"><a href="#efi-баиткод" class="header-anchor">#</a> EFI байткод</h3> <p>UEFI также включает спецификацию виртуальной машины, основанную на формате байтового кода, называемом EFI Byte Code (EBC), который может использоваться для написания независимых от платформы драйверов устройств, но не приложений UEFI. По состоянию на 2015 год использование EBC было ограниченным.</p> <h2 id="основные-проблемы"><a href="#основные-проблемы" class="header-anchor">#</a> Основные проблемы</h2> <h3 id="мое-приложение-uefi-зависает-сбрасывается-примерно-через-5-минут"><a href="#мое-приложение-uefi-зависает-сбрасывается-примерно-через-5-минут" class="header-anchor">#</a> Мое приложение UEFI зависает/сбрасывается примерно через 5 минут</h3> <p>Когда управление передается вашему приложению UEFI с помощью встроенного ПО, оно устанавливает таймер на 5 минут, после чего встроенное ПО повторно активируется, поскольку предполагается, что ваше приложение зависло. Прошивка в этом случае обычно пытается сбросить систему (хотя прошивка OVMF в VirtualBox просто приводит к тому, что экран становится черным и зависает). Чтобы противодействовать этому, вам необходимо обновить таймер до истечения времени ожидания. Кроме того, вы можете полностью отключить его с помощью такого кода, как</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>SystemTable<span class="token operator">-&gt;</span>BootServices<span class="token operator">-&gt;</span><span class="token function">SetWatchdogTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Очевидно, что это не проблема для большинства загрузчиков, но может вызвать проблему, если у вас есть интерактивный загрузчик, который ожидает ввода пользователя.</p> <h3 id="мои-загрузчик-зависает-если-я-использую-определенные-пользователем-значения-efi-memory-type"><a href="#мои-загрузчик-зависает-если-я-использую-определенные-пользователем-значения-efi-memory-type" class="header-anchor">#</a> Мой загрузчик зависает, если я использую определенные пользователем значения EFI_MEMORY_TYPE</h3> <p>Для функций управления памятью в EFI ОС должна иметься возможность использовать значения &quot;тип памяти&quot; выше 0x80000000 для своих собственных целей. В выпуске прошивки OVFM EFI &quot;r11337&quot; (для Qemu и т.д.) Есть ошибка, при которой прошивка предполагает, что тип памяти находится в диапазоне значений, определенных для собственного использования EFI, и использует тип памяти в качестве индекса массива. Конечным результатом является ошибка &quot;array index out of bounds&quot;&quot;; где более высокие значения типа памяти (например, разрешённые значения выше 0x80000000) приводят к сбою 64-разрядной версии прошивки (page fault) и приводят к тому, что 32-разрядная версия прошивки сообщает о неправильных значениях &quot;attribute&quot;. Эта же ошибка также присутствует в любой версии прошивки EFI, используемой VirtualBox (которая выглядит как более старая версия OVFM); и я подозреваю (но не знаю), что ошибка может присутствовать в самых разнообразных прошивках, которые были получены из проекта TianoCore (а не только OVFM).</p> <h2 id="внешние-ссылки"><a href="#внешние-ссылки" class="header-anchor">#</a> Внешние ссылки</h2> <ul><li><a href="https://uefi.org/specifications" target="_blank" rel="noopener noreferrer">UEFI Specifications<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.tianocore.org/" target="_blank" rel="noopener noreferrer">Intel TianoCore EDK2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF" target="_blank" rel="noopener noreferrer">OVMF firmware images<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://wiki.phoenix.com/" target="_blank" rel="noopener noreferrer">Phoenix UEFI Wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://x86asm.net/articles/others/index.html" target="_blank" rel="noopener noreferrer">Sereval articles about UEFI<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=19509" target="_blank" rel="noopener noreferrer">PE specification covering the (U)EFI binary format<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://uefi.blogspot.com/" target="_blank" rel="noopener noreferrer">Blog about UEFI, with bits about UEFI development<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://internshipatdell.wikispaces.com/file/view/How+to+build+an+UEFI+application.pptx" target="_blank" rel="noopener noreferrer">Presentation guiding through simple UEFI application setup<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf" target="_blank" rel="noopener noreferrer">Presentation giving an overview of windows uefi booting<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://gitlab.com/bztsrc/posix-uefi" target="_blank" rel="noopener noreferrer">POSIX-UEFI<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://wikipedia.org/wiki/Extensible_Firmware_Interface" target="_blank" rel="noopener noreferrer">Wikipedia Article on EFI<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/osdev/intro/languages.html" class="prev">
        Языки программирования
      </a></span> <span class="next"><a href="/osdev/intro/bios.html">
        BIOS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/osdev/assets/js/app.6d4e7c16.js" defer></script><script src="/osdev/assets/js/2.d8a8b755.js" defer></script><script src="/osdev/assets/js/25.f01e693e.js" defer></script>
  </body>
</html>
