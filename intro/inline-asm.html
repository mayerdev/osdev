<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Встроенная сборка | Разработка ОС</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="osdev.org на русском">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/osdev/assets/css/0.styles.cf6cd58c.css" as="style"><link rel="preload" href="/osdev/assets/js/app.6d4e7c16.js" as="script"><link rel="preload" href="/osdev/assets/js/2.d8a8b755.js" as="script"><link rel="preload" href="/osdev/assets/js/18.fd5dcd0e.js" as="script"><link rel="prefetch" href="/osdev/assets/js/10.f52dfc28.js"><link rel="prefetch" href="/osdev/assets/js/11.62d004c8.js"><link rel="prefetch" href="/osdev/assets/js/12.de6a66d3.js"><link rel="prefetch" href="/osdev/assets/js/13.5ce18855.js"><link rel="prefetch" href="/osdev/assets/js/14.2418957f.js"><link rel="prefetch" href="/osdev/assets/js/15.c118d926.js"><link rel="prefetch" href="/osdev/assets/js/16.d7ace87c.js"><link rel="prefetch" href="/osdev/assets/js/17.ed033aaf.js"><link rel="prefetch" href="/osdev/assets/js/19.401c7b19.js"><link rel="prefetch" href="/osdev/assets/js/20.69a7aab0.js"><link rel="prefetch" href="/osdev/assets/js/21.aa99a090.js"><link rel="prefetch" href="/osdev/assets/js/22.21e5a0d1.js"><link rel="prefetch" href="/osdev/assets/js/23.25b4c5a4.js"><link rel="prefetch" href="/osdev/assets/js/24.e3d90789.js"><link rel="prefetch" href="/osdev/assets/js/25.f01e693e.js"><link rel="prefetch" href="/osdev/assets/js/3.9d834bc1.js"><link rel="prefetch" href="/osdev/assets/js/4.15995e12.js"><link rel="prefetch" href="/osdev/assets/js/5.3392b390.js"><link rel="prefetch" href="/osdev/assets/js/6.a16b59c6.js"><link rel="prefetch" href="/osdev/assets/js/7.5089196a.js"><link rel="prefetch" href="/osdev/assets/js/8.83af78e0.js"><link rel="prefetch" href="/osdev/assets/js/9.f2730610.js">
    <link rel="stylesheet" href="/osdev/assets/css/0.styles.cf6cd58c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/osdev/" class="home-link router-link-active"><!----> <span class="site-name">Разработка ОС</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/osdev/intro/" class="nav-link router-link-active">
  Введение
</a></div><div class="nav-item"><a href="/osdev/teapot/" class="nav-link">
  Гайд для чайников
</a></div><div class="nav-item"><a href="/osdev/hardware/" class="nav-link">
  Аппаратная часть
</a></div><div class="nav-item"><a href="/osdev/os/" class="nav-link">
  Конструкция ОС
</a></div><div class="nav-item"><a href="/osdev/resources/" class="nav-link">
  Ресурсы
</a></div><div class="nav-item"><a href="/osdev/reference/" class="nav-link">
  Справочная информация
</a></div><div class="nav-item"><a href="/osdev/tools/" class="nav-link">
  Утилиты
</a></div><div class="nav-item"><a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Оригинал
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/osdev/intro/" class="nav-link router-link-active">
  Введение
</a></div><div class="nav-item"><a href="/osdev/teapot/" class="nav-link">
  Гайд для чайников
</a></div><div class="nav-item"><a href="/osdev/hardware/" class="nav-link">
  Аппаратная часть
</a></div><div class="nav-item"><a href="/osdev/os/" class="nav-link">
  Конструкция ОС
</a></div><div class="nav-item"><a href="/osdev/resources/" class="nav-link">
  Ресурсы
</a></div><div class="nav-item"><a href="/osdev/reference/" class="nav-link">
  Справочная информация
</a></div><div class="nav-item"><a href="/osdev/tools/" class="nav-link">
  Утилиты
</a></div><div class="nav-item"><a href="https://wiki.osdev.org/Main_Page" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Оригинал
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mayerdev/osdev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Введение</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/osdev/intro/" aria-current="page" class="sidebar-link">Главная</a></li><li><a href="/osdev/intro/required.html" class="sidebar-link">Необходимые знания</a></li><li><a href="/osdev/intro/mistakes.html" class="sidebar-link">Ошибки начинающих</a></li><li><a href="/osdev/intro/getting-started.html" class="sidebar-link">Начало работы</a></li><li><a href="/osdev/intro/kcl-linking.html" class="sidebar-link">Как ядро, компилятор и код на C работают вместе</a></li><li><a href="/osdev/intro/isr.html" class="sidebar-link">Обработка прерываний</a></li><li><a href="/osdev/intro/languages.html" class="sidebar-link">Языки программирования</a></li><li><a href="/osdev/intro/uefi.html" class="sidebar-link">UEFI</a></li><li><a href="/osdev/intro/bios.html" class="sidebar-link">BIOS</a></li><li><a href="/osdev/intro/inline-asm.html" aria-current="page" class="active sidebar-link">Встроенная сборка</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#основная-информация" class="sidebar-link">Основная информация</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#обзор" class="sidebar-link">Обзор</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#синтаксис" class="sidebar-link">Синтаксис</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#использование-c99" class="sidebar-link">Использование C99</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#назначение-меток" class="sidebar-link">Назначение меток</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#asm-goto" class="sidebar-link">asm goto</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#синтаксис-intel" class="sidebar-link">Синтаксис Intel</a></li><li class="sidebar-sub-header"><a href="/osdev/intro/inline-asm.html#внешние-ссылки" class="sidebar-link">Внешние ссылки</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Первые шаги</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/osdev/first-steps/bare-bones.html" class="sidebar-link">Голое железо</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="встроенная-сборка"><a href="#встроенная-сборка" class="header-anchor">#</a> Встроенная сборка</h1> <h2 id="основная-информация"><a href="#основная-информация" class="header-anchor">#</a> Основная информация</h2> <p>Идея встроенной сборки заключается в том, чтобы встроить инструкции ассемблера в код C/C++, используя ключевое слово asm, когда нет другого выбора, кроме как использовать язык ассемблера.</p> <h2 id="обзор"><a href="#обзор" class="header-anchor">#</a> Обзор</h2> <p>Иногда, даже несмотря на то, что C/C++ является вашим основным языком, вам необходимо использовать некоторый код ассемблера в вашей операционной системе. Будь то из-за экстремальных потребностей в оптимизации или из-за того, что код, который вы реализуете, сильно зависит от оборудования (например, например, вывод данных через порт), результат один и тот же: обойти его невозможно. Вы должны использовать ассемблер.</p> <p>Один из вариантов, который у вас есть, - это написать функцию asm и вызвать ее, однако могут быть случаи, когда даже накладные расходы на &quot;вызов&quot; слишком велики для вас. В этом случае вам нужна встроенная сборка, что означает вставку произвольных фрагментов asm в середине кода с использованием ключевого слова asm(). Способ работы этого ключевого слова зависит от компилятора. В этой статье описывается, как он работает в GCC, поскольку это, безусловно, самый используемый компилятор в мире ОС.</p> <h2 id="синтаксис"><a href="#синтаксис" class="header-anchor">#</a> Синтаксис</h2> <p>Это синтаксис для использования ключевого слова asm() в коде C/C++:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span> <span class="token punctuation">(</span> assembler <span class="token keyword">template</span>
    <span class="token operator">:</span> output <span class="token function">operands</span>                   <span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
    <span class="token operator">:</span> input <span class="token function">operands</span>                    <span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
    <span class="token operator">:</span> clobbered registers <span class="token function">list</span>          <span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Шаблон ассемблера - это в основном код, совместимый с GAS, за исключением случаев, когда у вас есть ограничения, и в этом случае имена регистров должны начинаться с %% вместо %. Это означает, что следующие две строки кода будут перемещать содержимое регистра eax в ebx:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span> <span class="token punctuation">(</span><span class="token string">&quot;movl %eax, %ebx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">asm</span> <span class="token punctuation">(</span><span class="token string">&quot;movl %%eax, %%ebx&quot;</span> <span class="token operator">:</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Теперь вы можете задаться вопросом, почему появляется этот %%. Именно здесь появляется интересная особенность встроенной сборки: вы можете использовать некоторые из ваших переменных C в своем ассемблерном коде. И поскольку, чтобы упростить реализацию этого механизма, GCC называет эти переменные %0, %1 и так Далее в вашем ассемблерном коде, начиная с первой переменной, упомянутой в разделах операндов ввода/вывода. Вы должны использовать этот синтаксис %%, чтобы помочь GCC различать регистры и параметры.</p> <p>Как именно работают операнды, будет более подробно объяснено в последующих разделах. На данный момент достаточно сказать, что если вы напишете что-то подобное:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token keyword">asm</span> <span class="token punctuation">(</span>&quot;movl <span class="token operator">%</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>eax<span class="token punctuation">;</span> 
      movl <span class="token operator">%</span><span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span><span class="token number">0</span><span class="token punctuation">;</span>&quot;
     <span class="token operator">:</span><span class="token string">&quot;=r&quot;</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token comment">/* вывод */</span>
     <span class="token operator">:</span><span class="token string">&quot;r&quot;</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>         <span class="token comment">/* ввод */</span>
     <span class="token operator">:</span><span class="token string">&quot;%eax&quot;</span>         <span class="token comment">/* регистр */</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>то вам удалось скопировать значение <code>a</code> в <code>b</code> с помощью ассемблерного кода, эффективно используя некоторые переменные C в вашем ассемблерном коде. Поздравляю!</p> <p>Последний раздел &quot;clobbered register&quot; используется для того, чтобы сообщить GCC, что ваш код использует некоторые регистры процессора и что он должен переместить любые активные данные из запущенной программы из этого регистра перед выполнением фрагмента asm. В приведенном выше примере мы перемещаем a в eax в первой инструкции, эффективно стирая ее содержимое, поэтому нам нужно попросить GCC очистить этот регистр от несохраненных данных перед операцией.</p> <h3 id="шаблон-ассемблера"><a href="#шаблон-ассемблера" class="header-anchor">#</a> Шаблон ассемблера</h3> <p>Шаблон ассемблера определяет встроенные инструкции ассемблера. По умолчанию здесь используется синтаксис AT&amp;T. Если вы хотите использовать синтаксис Intel, <strong>-masm=intel</strong> следует указать в качестве параметра командной строки.</p> <p>Например, чтобы остановить процессор, вам просто нужно использовать следующую команду:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;hlt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="выходные-операнды"><a href="#выходные-операнды" class="header-anchor">#</a> Выходные операнды</h3> <p>Выходные операнды используется для того, чтобы указать компилятору/ассемблеру, как он должен обрабатывать переменные C, используемые для хранения некоторых выходных данных из кода ASM. Выходные операнды представляют собой список пар, каждый из которых состоит из строкового литерала, известного как &quot;ограничение&quot;, указывающего, где должна быть отображена переменная C (регистры обычно используются для оптимальной производительности), и переменной C для отображения (в скобках).</p> <p>В ограничении &quot;a&quot; относится к EAX, &quot;b&quot; - к EBX, &quot;c&quot; - к ECX, &quot;d&quot; - к EDX, &quot;S&quot; - к ESI и &quot;D&quot; - к EDI (полный список см. в руководстве GCC), предполагая, что вы разрабатываете для архитектуры IA32. Знак уравнения указывает на то, что ваш ассемблерный код не заботится о начальном значении сопоставленной переменной (что позволяет произвести некоторую оптимизацию). Учитывая все это, теперь совершенно ясно, что следующий код устанавливает EAX = 0.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> EAX<span class="token punctuation">;</span>
<span class="token keyword">asm</span><span class="token punctuation">(</span> <span class="token string">&quot;movl $0, %0&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;=a&quot;</span> <span class="token punctuation">(</span>EAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Обратите внимание, что компилятор перечисляет операнд, начинающийся с %0, и что вам не нужно добавлять регистр в список заблокированных регистров, если он используется для хранения выходного операнда. GCC достаточно умен, чтобы самостоятельно решить, что делать.</p> <p>Начиная с GCC 3.1, вы можете использовать более читаемые метки вместо перечисления, подверженного ошибкам:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> current_task<span class="token punctuation">;</span>
<span class="token keyword">asm</span><span class="token punctuation">(</span> <span class="token string">&quot;str %[output]&quot;</span> <span class="token operator">:</span> <span class="token punctuation">[</span>output<span class="token punctuation">]</span> <span class="token string">&quot;=r&quot;</span> <span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Эти метки находятся в собственном пространстве имен и не будут сталкиваться с какими-либо идентификаторами C. То же самое можно сделать и для входных операндов.</p> <h3 id="входные-операнды"><a href="#входные-операнды" class="header-anchor">#</a> Входные операнды</h3> <p>В то время как выходные операнды обычно используются для... хорошо... на выходе входные операнды позволяют параметризовать код ASM, т.е. передавать параметры только для чтения из кода C в блок ASM. Опять же, строковые литералы используются для указания деталей.</p> <p>Если вы хотите переместить какое-то значение в EAX, вы можете сделать это следующим образом (хотя, конечно, было бы довольно бесполезно делать это вместо прямого сопоставления значения с EAX):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> randomness <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">asm</span><span class="token punctuation">(</span> <span class="token string">&quot;movl %0, %%eax&quot;</span>
   <span class="token operator">:</span>
   <span class="token operator">:</span> <span class="token string">&quot;b&quot;</span> <span class="token punctuation">(</span>randomness<span class="token punctuation">)</span>
   <span class="token operator">:</span> <span class="token string">&quot;eax&quot;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Обратите внимание, что GCC всегда будет предполагать, что входные операнды доступны только для чтения (без изменений). Правильная вещь, которую нужно сделать, когда входные операнды записываются, - это перечислить их в качестве выходных данных, но без использования знака уравнения, потому что на этот раз их исходное значение имеет значение. Вот простой пример:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;mov %%eax,%%ebx&quot;</span><span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// бесполезно, но идея крутая</span>
</code></pre></div><h3 id="список-сбитых-регистров"><a href="#список-сбитых-регистров" class="header-anchor">#</a> Список сбитых регистров</h3> <p>Важно помнить одну вещь: компилятор C/C++ ничего не знает об ассемблере. Для компилятора оператор asm непрозрачен, и если вы не указали никаких выходных данных, он может даже прийти к выводу, что это не операция, и оптимизировать его. Некоторые сторонние документы указывают, что использование asm volatile приведет к тому, что ключевое слово не будет перемещено. Однако, согласно документации GCC, ключевое слово volatile указывает на то, что инструкция имеет важные побочные эффекты. GCC не удалит изменчивый asm, если он доступен, что указывает только на то, что он не будет удален (т.е. вопрос о том, может ли он все еще быть перемещен, остается без ответа). Подход, который должен работать, состоит в том, чтобы использовать asm (volatile) и помещать память в регистры clobber, например:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">&quot;cli&quot;</span><span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Это приведет к тому, что оператор не будет перемещен, но он может быть оптимизирован.</span>
__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;cli&quot;</span><span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Это приведет к тому, что оператор не будет ни перемещен, ни оптимизирован.</span>
</code></pre></div><p>Поскольку компилятор использует регистры процессора для внутренней оптимизации ваших переменных C/C++ и не знает об опкодах ASM, вы должны предупредить его о любых регистрах, которые могут быть заблокированы в качестве побочного эффекта, чтобы компилятор мог сохранить их содержимое перед вызовом ASM.</p> <p>Список сбитых регистров представляет собой разделенный запятыми список имен регистров в виде строковых литералов.</p> <h3 id="wildcards-как-вы-можете-позволить-компилятору-выбирать"><a href="#wildcards-как-вы-можете-позволить-компилятору-выбирать" class="header-anchor">#</a> Wildcards: как вы можете позволить компилятору выбирать</h3> <p>Вам не нужно указывать компилятору, какой конкретный регистр он должен использовать в каждой операции, и в целом, за исключением случаев, когда у вас есть веские причины предпочесть один конкретный регистр, вам лучше позволить компилятору решать за вас.</p> <p>Например, принудительное использование EAX над любым другим регистром может вынудить компилятор выдать код, который сохранит то, что ранее было в eax, в каком-либо другом регистре или может ввести нежелательные зависимости между операциями (нарушена оптимизация).</p> <p>Ограничения &quot;wildcards&quot; позволяют предоставить больше свободы GCC, когда дело доходит до сопоставления ввода/вывода:</p> <p>Ограничение &quot;g&quot;:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;movl $0, %0&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;=g&quot;</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// x может быть тем, что предпочитает компилятор: регистром, ссылкой на память. Это может быть даже буквальная константа в другом контексте.</span>
</code></pre></div><p>Ограничение &quot;r&quot;:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;movl %%es, %0&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;=r&quot;</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// вы хотите, чтобы x прошел через реестр. Если x не был оптимизирован как регистр, компилятор переместит его в нужное место. Это означает, что &quot;movl %0, %%es&quot; : : &quot;r&quot; (0x38) достаточно для загрузки регистра сегмента.</span>
</code></pre></div><p>Ограничение &quot;N&quot;:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;outl %0, %1&quot;</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">(</span><span class="token number">0xFE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;N&quot;</span> <span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span> <span class="token comment">// указывает, что значение &quot;0x21&quot; может использоваться в качестве константы в результате или в работе, если оно находится в диапазоне от 0 до 255</span>
</code></pre></div><p>Конечно, существует гораздо больше ограничений, которые вы можете наложить на выбор операнда, зависящего от машины или нет, которые перечислены в руководстве GCC (см. <a href="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Simple-Constraints.html#Simple-Constraints" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Modifiers.html#Modifiers" target="_blank" rel="noopener noreferrer">2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Multi_002dAlternative.html#Multi_002dAlternative" target="_blank" rel="noopener noreferrer">3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, и <a href="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Machine-Constraints.html#Machine-Constraints" target="_blank" rel="noopener noreferrer">4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>).</p> <h2 id="использование-c99"><a href="#использование-c99" class="header-anchor">#</a> Использование C99</h2> <p>asm не является ключевым словом при использовании <strong>gcc-std=c99</strong>. Просто используйте <strong>gcc -std=gnu99</strong>, чтобы использовать C99 с расширениями GNU. Кроме того, вы можете использовать _<em>asm</em>_ в качестве альтернативного ключевого слова, которое работает даже тогда, когда компилятор строго придерживается стандарта.</p> <h2 id="назначение-меток"><a href="#назначение-меток" class="header-anchor">#</a> Назначение меток</h2> <p>Можно назначить так называемые метки ASM ключевым словам C/C++. Это можно сделать с помощью команды asm для определений переменных, как показано в этом примере:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> some_obscure_name <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;param&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// &quot;param&quot; будет доступен во встроенной сборке</span>
 
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;mov param, %%eax&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Вот пример того, как вы можете получить доступ к этим переменным, если вы явно не указываете имя:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> some_obscure_name <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;mov some_obscure_name, %%eax&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Обратите внимание, что вам также может потребоваться использовать <strong>_some_obscure_name</strong> (с начальным подчеркиванием), в зависимости от ваших параметров компоновки.</p> <h2 id="asm-goto"><a href="#asm-goto" class="header-anchor">#</a> asm goto</h2> <p>До GCC 4.5 переход через встроенные asm не поддерживался. Компилятор не может отслеживать, что происходит, поэтому почти гарантированно будет сгенерирован неправильный код.</p> <p>Возможно, вам сказали, что &quot;гото-это зло&quot;. Если вы верите, что это так, то asm goto-это ваш худший кошмар, который сбывается. Тем не менее, он предлагает некоторые интересные варианты оптимизации кода.</p> <p>asm goto не очень хорошо документирован, но его синтаксис выглядит следующим образом:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span> <span class="token keyword">goto</span><span class="token punctuation">(</span> <span class="token string">&quot;jmp %l[labelname]&quot;</span> <span class="token operator">:</span> <span class="token comment">/* нет вывода */</span> <span class="token operator">:</span> <span class="token comment">/* ввод */</span> <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span> <span class="token operator">:</span> labelname <span class="token comment">/* любые метки */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Одним из примеров, где это может быть полезно, является инструкция CMPXCHG (см. <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%BE%D0%BC" target="_blank" rel="noopener noreferrer">Сравнение c Обменом<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>), которую исходный код ядра Linux определяет следующим образом:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">cmpxchg</span><span class="token expression"><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> _old<span class="token punctuation">,</span> _new <span class="token punctuation">)</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">volatile</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>__ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>   </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">uint32_t</span> __ret<span class="token punctuation">;</span>                                     </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span> </span><span class="token string">&quot;lock; cmpxchgl %2,%1&quot;</span>           <span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> </span><span class="token string">&quot;=a&quot;</span> <span class="token expression"><span class="token punctuation">(</span>__ret<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">&quot;+m&quot;</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span>__ptr<span class="token punctuation">)</span>                </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> </span><span class="token string">&quot;r&quot;</span> <span class="token expression"><span class="token punctuation">(</span>_new<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">&quot;0&quot;</span> <span class="token expression"><span class="token punctuation">(</span>_old<span class="token punctuation">)</span>                     </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> </span><span class="token string">&quot;memory&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>				 </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>                                             </span><span class="token punctuation">\</span>
  <span class="token expression">__ret<span class="token punctuation">;</span>                                         </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span></span></span>
</code></pre></div><p>В дополнение к возвращению текущего значения в EAX, CMPXCHG устанавливает нулевой флаг (Z) при успешном выполнении. Без asm goto ваш код должен будет проверить возвращаемое значение; этой инструкции CMP можно избежать следующим образом:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Работает на x86 и x86-64</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">cmpxchg</span><span class="token expression"><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> _old<span class="token punctuation">,</span> _new<span class="token punctuation">,</span> fail_label <span class="token punctuation">)</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">volatile</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>__ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>   </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">goto</span><span class="token punctuation">(</span> </span><span class="token string">&quot;lock; cmpxchg %1,%0 \t\n&quot;</span>           <span class="token punctuation">\</span>
    <span class="token string">&quot;jnz %l[&quot;</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">fail</span><span class="token expression">_label </span></span></span><span class="token string">&quot;] \t\n&quot;</span>               <span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> </span><span class="token comment">/* ничего */</span>                                <span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> </span><span class="token string">&quot;m&quot;</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span>__ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">&quot;r&quot;</span> <span class="token expression"><span class="token punctuation">(</span>_new<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">&quot;a&quot;</span> <span class="token expression"><span class="token punctuation">(</span>_old<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> </span><span class="token string">&quot;memory&quot;</span><span class="token expression"><span class="token punctuation">,</span> </span><span class="token string">&quot;cc&quot;</span>                             <span class="token punctuation">\</span>
    <span class="token expression"><span class="token operator">:</span> fail_label <span class="token punctuation">)</span><span class="token punctuation">;</span>                              </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span></span></span>
</code></pre></div><p>Затем этот новый макрос можно использовать следующим образом:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>
  <span class="token keyword">volatile</span> <span class="token keyword">struct</span> <span class="token class-name">Item</span> <span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">volatile</span> <span class="token keyword">struct</span> <span class="token class-name">Item</span> <span class="token operator">*</span> head<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Item</span> <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">volatile</span> <span class="token keyword">struct</span> <span class="token class-name">Item</span> <span class="token operator">*</span> oldHead<span class="token punctuation">;</span>
again<span class="token operator">:</span>
  oldHead <span class="token operator">=</span> head<span class="token punctuation">;</span>
  i<span class="token operator">-&gt;</span>next <span class="token operator">=</span> oldHead<span class="token punctuation">;</span>
  <span class="token function">cmpxchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> oldHead<span class="token punctuation">,</span> i<span class="token punctuation">,</span> again<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="синтаксис-intel"><a href="#синтаксис-intel" class="header-anchor">#</a> Синтаксис Intel</h2> <p>Вы можете разрешить GCC использовать синтаксис intel, включив его во встроенной сборке, например:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;.intel_syntax noprefix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;mov eax, ebx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Аналогично, вы можете вернуться к синтаксису AT&amp;T, используя следующий фрагмент кода:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;.att_syntax prefix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;mov %ebx, %eax&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block danger"><p class="custom-block-title">Важно</p> <p>Таким образом, вы можете объединить синтаксис Intel и встроенную сборку синтаксиса AT&amp;T. Обратите внимание, что как только вы запустите один из этих типов синтаксиса, все, что ниже команды в исходном файле, будет собрано с использованием этого синтаксиса, поэтому не забудьте переключиться обратно, когда это необходимо, или вы можете получить много ошибок компиляции!</p></div> <p>Существует также опция командной строки <strong>-masm=intel</strong> для глобального запуска синтаксиса Intel.</p> <h2 id="внешние-ссылки"><a href="#внешние-ссылки" class="header-anchor">#</a> Внешние ссылки</h2> <ul><li><a href="http://gcc.gnu.org/onlinedocs/" target="_blank" rel="noopener noreferrer">GCC Manuals<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://web.archive.org/web/20041210030000/http://www-106.ibm.com/developerworks/library/l-ia.html" target="_blank" rel="noopener noreferrer">Inline assembly for x86 in Linux (by IBM)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://msdn.microsoft.com/en-us/library/26td21ds(VS.80).aspx" target="_blank" rel="noopener noreferrer">Visual C++ Compiler Intrinsics<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/osdev/intro/bios.html" class="prev">
        BIOS
      </a></span> <span class="next"><a href="/osdev/first-steps/bare-bones.html">
        Голое железо
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/osdev/assets/js/app.6d4e7c16.js" defer></script><script src="/osdev/assets/js/2.d8a8b755.js" defer></script><script src="/osdev/assets/js/18.fd5dcd0e.js" defer></script>
  </body>
</html>
