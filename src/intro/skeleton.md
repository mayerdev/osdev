# Пример организации ОС

## Основная информация

В этом уроке мы продолжим с первых шагов и создадим минимальную операционную систему-шаблон, подходящую для дальнейшей модификации или в качестве вдохновения для вашей начальной версии операционной системы. Туториал "Первые шаги" даёт вам только абсолютно минимальный код, чтобы продемонстрировать, как правильно скомпилировать ядро, однако это не подходит в качестве примера операционной системы. Кроме того, в этом туториале реализованы необходимые функции ABI, необходимые для выполнения функций ABI и компилятора, чтобы предотвратить возможные неожиданные ошибки.

Этот туториал также служит в качестве начального гайда по тому, как создать свой собственный libc (Стандартная библиотека C). В документации GCC явно указано, что libgcc требует, чтобы автономная среда предоставляла функции memcmp, memcpy, memmove и memset. Мы выполним это требование, создав специальную библиотеку C-ядра (libk), которая содержит части пользовательского пространства libc, которые являются автономными (не требуют каких-либо функций ядра), в отличие от существующих функций libc, которые должны выполнять системные вызовы.

## Предисловие

Этот туториал является примером того, как вы можете структурировать свою операционную систему таким образом, чтобы вам не приходилось постоянно рефакторить её в будущем.

Мы назовём нашу ОС `myos`. Вы можете далее использовать это название или придумать своё.

## Настройка кросс-компилятора

Вы должны использовать таргет i686-elf в своем кросс-компиляторе.

Также вы должны сконфигурить cross-binutils с параметром --with-sysroot, иначе линковка завершится ошибкой this linker was not configured to use sysroots. Если вы забыли собрать cross-binutils с этим параметром, вам придется пересобрать его(пересобирать GCC необязательно).

## Зависимости ~~разработчика после создания ОС~~

Вам понадобятся эти инструменты:

* i686-набор инструментов elf.
* GRUB, для команды grub-mkrescue, вместе с соответствующими runtime-файлами.
* Xorriso, для создания .iso, используемый grub-mkrescue.
* GNU make 4.0 или более поздней версии.
* QEMU, для тестирования операционной системы.

Вам потребуется система основанная на GNU/Linux.

### Для пользователей Debian

Установите набор инструментов `i686-elf`, а затем установите пакеты `xorriso` `grub-pc-bin`.

## Sysroot

Обычно при компиляции программ для локальной операционной системы компилятор находит заголовки и библиотеки, в системных каталогах, таких как:

- /usr/include
- /usr/lib

Эти файлы конечно могут не использоваться в вашей ОС, скорее всего вы будете использовать собственные пути, например:

- /home/depowered/myos/sysroot/usr/include
- /home/depowered/myos/sysroot/usr/lib

Каталог `/home/depowered/myos/sysroot` будет работать как sysroot-каталог для вашей ОС.

:::tip Что такое sysroot?
Sysroot - это каталог, который считается корневым каталогом для поиска заголовков и библиотек. Так, например, если ваша сборка toolchain хочет найти /usr/include/foo.h но вы выполняете кросс-компиляцию, а соответствующий foo.h находится в /my/other/place/usr/include/foo.h, вы будете использовать /my/other/place как ваш sysroot.
:::

## Заголовки

`./headers.sh` просто устанавливает заголовки для вашего libc и ядра (системные заголовки) в `sysroot/usr/include`, но на самом деле не скомпилирует вашу операционную систему. Это полезно, так как позволяет предоставить компилятору копию ваших заголовков до того, как вы фактически скомпилируете свою систему.

## Makefile

Makefile — это файл, содержащий набор инструкций, используемых утилитой make в инструментарии автоматизации сборки. Чаще всего makefile содержит указания для утилиты make о том, как компилировать и компоновать программу.

Пример Makefile:

```makefile
# Дефолтные CFLAGS:
CFLAGS?=-O2 -g
 
# Дополнительные параметры CFLAGS:
CFLAGS:=$(CFLAGS) -Wall -Wextra
```

