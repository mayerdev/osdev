(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{412:function(t,a,s){"use strict";s.r(a);var e=s(52),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"uefi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uefi"}},[t._v("#")]),t._v(" UEFI")]),t._v(" "),s("h2",{attrs:{id:"основная-информация"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#основная-информация"}},[t._v("#")]),t._v(" Основная информация")]),t._v(" "),s("p",[t._v("(U)EFI или (Унифицированный) Расширяемый Интерфейс микропрограммного обеспечения - это спецификация для платформ x86, x86-64, ARM и Itanium, которая определяет программный интерфейс между операционной системой и микропрограммным обеспечением платформы/BIOS. Оригинальный EFI был разработан в середине 1990-х годов компанией Intel для разработки встроенного ПО/BIOS для платформ Itanium. В 2005 году Intel передала спецификацию новой рабочей группе под названием Unified EFI Forum, состоящей из таких компаний, как AMD, Microsoft, Apple и сама Intel. Все современные ПК поставляются с прошивкой UEFI, UEFI широко поддерживается как коммерческими, так и операционными системами с открытым исходным кодом. Обратная совместимость предусмотрена для устаревших операционных систем.")]),t._v(" "),s("h2",{attrs:{id:"основы-uefi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#основы-uefi"}},[t._v("#")]),t._v(" Основы UEFI")]),t._v(" "),s("h3",{attrs:{id:"загрузка-образов-uefi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#загрузка-образов-uefi"}},[t._v("#")]),t._v(" Загрузка образов UEFI")]),t._v(" "),s("p",[t._v('Если вы используете VirtualBox для виртуализации, то UEFI уже включен, нет необходимости загружать образ вручную. Вам просто нужно включить его в настройках виртуальной машины, нажав флажок "Настройки" / "Системы" / "Включить EFI (только специальные операционные системы)".')]),t._v(" "),s("p",[t._v("В противном случае для эмуляции и виртуальных машин вам понадобится образ прошивки OVMF.fd. Это может быть сложно найти, поэтому вот несколько альтернативных ссылок для загрузки:")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://github.com/tianocore/tianocore.github.io/wiki/OVMF",target:"_blank",rel:"noopener noreferrer"}},[t._v("TianoCore"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/BlankOn/ovmf-blobs",target:"_blank",rel:"noopener noreferrer"}},[t._v("OVMF-blobs"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.kraxel.org/repos/",target:"_blank",rel:"noopener noreferrer"}},[t._v("RPM packages"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://packages.debian.org/sid/ovmf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Debian packages"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://packages.gentoo.org/useflags/ovmf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Gentoo packages"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://aur.archlinux.org/packages/ovmf-git/?comments=all",target:"_blank",rel:"noopener noreferrer"}},[t._v("Arch packages"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("В Linux вы также можете установить их с помощью диспетчера пакетов вашего дистрибутива, например:")]),t._v(" "),s("h4",{attrs:{id:"debian-ubuntu"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#debian-ubuntu"}},[t._v("#")]),t._v(" Debian / Ubuntu")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt-get")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" ovmf\n")])])]),s("h4",{attrs:{id:"redhat-centos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redhat-centos"}},[t._v("#")]),t._v(" RedHat / CentOS")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("yum "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" ovmf\n")])])]),s("h4",{attrs:{id:"macos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#macos"}},[t._v("#")]),t._v(" macOS")]),t._v(" "),s("p",[t._v("Используйте репозиторий OVMF-blobs.")]),t._v(" "),s("h4",{attrs:{id:"windows"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#windows"}},[t._v("#")]),t._v(" Windows")]),t._v(" "),s("p",[t._v("Используйте репозиторий OVMF-blobs или загрузите RPM-версию, затем с помощью 7-Zip распакуйте файл OVMF.fd из загруженного архива.")]),t._v(" "),s("h3",{attrs:{id:"uefi-против-bios"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uefi-против-bios"}},[t._v("#")]),t._v(" UEFI против BIOS")]),t._v(" "),s("p",[t._v("Распространенным заблуждением является то, что UEFI является заменой BIOS. На самом деле, как устаревшие материнские платы, так и материнские платы на основе UEFI поставляются с ПЗУ BIOS, которые содержат встроенное ПО, которое выполняет начальную настройку системы при включении питания, прежде чем загружать какой-либо сторонний код в память и переходить к нему. Различия между устаревшей прошивкой BIOS и прошивкой UEFI BIOS заключаются в том, где они находят этот код, как они готовят систему перед переходом к ней и какие удобные функции они предоставляют для вызова кода во время работы.")]),t._v(" "),s("h4",{attrs:{id:"инициализация-платформы"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#инициализация-платформы"}},[t._v("#")]),t._v(" Инициализация платформы")]),t._v(" "),s("p",[t._v("BIOS выполняет всю инициализацию платформы (конфигурация контроллера памяти, конфигурация шины PCI и BAR-mapping, инициализация видеокарты и т.д.), но затем переходит в обратно совместимую среду Real Mode. Загрузчик должен включить A20-gate, настроить GDT и IDT, переключиться в Protected Mode, а для процессоров x86-64 настроить подкачку и переключиться в Long Mode.")]),t._v(" "),s("p",[t._v("Прошивка UEFI выполняет те же шаги, но также подготавливает среду Protected Mode с плоской сегментацией, а для процессоров x86-64-среду Long mode с отображением идентификаторов подкачки. A20-gate также включён.")]),t._v(" "),s("p",[t._v("Кроме того, процедура инициализации платформы прошивки UEFI стандартизирована. Это позволяет распространять прошивку UEFI независимо от поставщика платы.")]),t._v(" "),s("h4",{attrs:{id:"механизм-загрузки"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#механизм-загрузки"}},[t._v("#")]),t._v(" Механизм загрузки")]),t._v(" "),s("p",[t._v("BIOS загружает 512-байтовый двоичный объект из загрузочного устройства типа MBR(Master Boot Record) в память по физическому адресу 7C00 и переходит к нему. Загрузчик не может вернуться обратно в BIOS. Прошивка UEFI загружает приложение UEFI произвольного размера (исполняемый файл PE) из раздела FAT на загрузочном устройстве с разделом GPT на некоторый адрес, выбранный во время выполнения. Затем он вызывает основную точку входа этого приложения. Приложение может вернуть управление встроенному ПО, которое продолжит поиск другого загрузочного устройства или вызовет меню диагностики.")]),t._v(" "),s("h4",{attrs:{id:"обнаружение-системы"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#обнаружение-системы"}},[t._v("#")]),t._v(" Обнаружение системы")]),t._v(" "),s("p",[t._v("BIOS сканирует память на наличие таких структур, как таблицы EBDA, SMBIOS и ACPI. Он использует PIO для связи с корневым контроллером PCI и сканирования шины PCI. Возможно, что в памяти могут присутствовать избыточные таблицы (например, таблица MP в SMBIOS содержит информацию, которая также присутствует в DSDT ACPI), и загрузчик может выбрать, какие из них использовать.")]),t._v(" "),s("p",[t._v('Когда UEFI вызывает функцию точки входа UEFI-приложения, она передает структуру "Системной таблицы", которая содержит указатели на все таблицы ACPI системы, карту памяти и другую информацию, относящуюся к ОС. Устаревшие таблицы (например, SMBIOS) могут отсутствовать в памяти.')]),t._v(" "),s("h4",{attrs:{id:"удобные-функции"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#удобные-функции"}},[t._v("#")]),t._v(" Удобные функции")]),t._v(" "),s("p",[t._v("BIOS подключает различные прерывания, которые загрузчик может запускать для доступа к системным ресурсам, таким как диски и экран. Эти прерывания не стандартизированы, за исключением исторических условностей. Каждое прерывание использует другое для передачи регистра.")]),t._v(" "),s("p",[t._v('UEFI устанавливает в памяти множество вызываемых функций, которые группируются в наборы, называемые "протоколами", и которые можно обнаружить через системную таблицу. Поведение каждой функции в каждом протоколе определяется спецификацией. Приложения UEFI могут определять свои собственные протоколы и сохранять их в памяти для использования другими UEFI-приложениями. Функции вызываются с помощью стандартизированного, современного стандарта системных вызовов, поддерживаемого многими компиляторами языка C.')]),t._v(" "),s("h4",{attrs:{id:"среда-разработки"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#среда-разработки"}},[t._v("#")]),t._v(" Среда разработки")]),t._v(" "),s("p",[t._v("Устаревшие загрузчики могут быть разработаны в любой среде, которая может генерировать двоичные образы: NASM, GCC и т.д. Приложения UEFI могут быть разработаны на любом языке, который может быть скомпилирован и связан в исполняемый файл PE и поддерживает соответствующие вызовы, используемые для доступа к функциям, установленным в памяти прошивкой UEFI. На практике это означает одну из двух сред разработки: Intel TianoCore EDK2, GNU-EFI или POSIX-UEFI.")]),t._v(" "),s("p",[t._v("TianoCore - это большая, сложная среда с собственной системой сборки. Его можно настроить для использования вместе с GCC, MinGW, Microsoft Visual C++ и т.д. Его можно использовать не только для компиляции UEFI-приложений, но и для компиляции прошивки UEFI, которая будет перенесена в ПЗУ BIOS.")]),t._v(" "),s("p",[t._v("GNU-EFI - это набор библиотек и заголовков для компиляции приложений UEFI с собственным GCC системы (не работает с LLVM CLang). Он не может быть использован для компиляции прошивки UEFI. Поскольку это всего лишь пара библиотек, с которыми можно связать UEFI-приложение, его гораздо проще использовать, чем TianoCore.")]),t._v(" "),s("p",[t._v("POSIX-UEFI очень похож на GNU-EFI, но он распространяется в основном как исходный код, а не как двоичная библиотека, имеет имена, подобные ANSI C, и работает с GCC, а также с LLVM CLang. Он поставляется с файлом Makefile.")]),t._v(" "),s("h4",{attrs:{id:"эмуляция"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#эмуляция"}},[t._v("#")]),t._v(" Эмуляция")]),t._v(" "),s("p",[t._v("Bochs поставляется с BIOS с открытым исходным кодом по умолчанию. Кроме того, SeaBIOS, популярный BIOS, который был портирован как на эмулированные машины Bochs, так и на машины с эмуляцией QEMU. Оба этих BIOSs реализуют большинство функций BIOS, которые можно было бы ожидать. Тем не менее, они довольно значительно отличаются по эксплуатации от коммерческих BIOS на реальных машинах.")]),t._v(" "),s("p",[t._v("OVMF, популярная прошивка UEFI с открытым исходным кодом, была перенесена на эмулируемую машину QEMU (но не Bochs). Поскольку он реализует спецификацию UEFI, он ведет себя очень похоже на коммерческую прошивку UEFI на реальных машинах. (Сам OVMF построен с помощью TianoCore, но доступны готовые образы.)")]),t._v(" "),s("h3",{attrs:{id:"загрузчик-bios-или-приложение-для-uefi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#загрузчик-bios-или-приложение-для-uefi"}},[t._v("#")]),t._v(" Загрузчик BIOS или приложение для UEFI?")]),t._v(" "),s("p",[t._v("Если вы ориентируетесь на устаревшие системы, для которых UEFI недоступен или ненадежен, вам следует разработать загрузчик для BIOS. Это требует глубокого знания 16-битной адресации и функций обратной совместимости процессора x86 или x86-64. Если вы ориентируетесь на современные системы, вам следует разработать UEFI-приложение. Многие прошивки UEFI могут быть сконфигурированы для эмуляции BIOS, но среди этих эмулируемых сред существует еще больше различий, чем среди реальных BIOS.")]),t._v(" "),s("h3",{attrs:{id:"uefi-0-3-класса-и-csm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uefi-0-3-класса-и-csm"}},[t._v("#")]),t._v(" UEFI 0-3 класса и CSM")]),t._v(" "),s("p",[t._v("ПК классифицируются как класс UEFI 0, 1, 2 или 3. Машина класса 0-это устаревшая система с BIOS, т.е. Вообще не система UEFI.")]),t._v(" "),s("p",[t._v('Машина класса 1 - это система с UEFI, которая работает исключительно в режиме модуля поддержки совместимости (CSM). CSM - это спецификация того, как прошивка UEFI может эмулировать устаревший BIOS. Прошивка UEFI в режиме CSM загружает Legacy-загрузчики. Система UEFI класса 1 может вообще не декларировать поддержку UEFI, поскольку она не доступна загрузчику. Это только UEFI "внутри" BIOS.')]),t._v(" "),s("p",[t._v("Машина класса 2 - это система UEFI, которая может запускать UEFI-приложения, но также включает в себя возможность запуска в режиме CSM. Большинство современных ПК - это машины класса UEFI 2. Иногда выбор для запуска UEFI-приложений против CSM - это тот или иной параметр в конфигурации BIOS, и в других случаях BIOS решит, какой из них использовать, после выбора загрузочного устройства и проверки того, у него Legacy-загрузчик или UEFI-приложение.")]),t._v(" "),s("p",[t._v("Машина класса 3 - это система UEFI, которая не поддерживает CSM. Машины класса 3 UEFI запускают только UEFI-приложения и не реализуют CSM для обратной совместимости с Legacy-загрузчиками.")]),t._v(" "),s("h3",{attrs:{id:"безопасная-загрузка-secure-boot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#безопасная-загрузка-secure-boot"}},[t._v("#")]),t._v(" Безопасная загрузка (Secure Boot)")]),t._v(" "),s("p",[t._v("Безопасная загрузка - это схема цифровой подписи для приложений UEFI, состоящая из четырех компонентов:")]),t._v(" "),s("ul",[s("li",[t._v("PK: Ключ платформы")]),t._v(" "),s("li",[t._v("KEK: Ключ для обмена ключей")]),t._v(" "),s("li",[t._v("db: Белый список")]),t._v(" "),s("li",[t._v("dbx: Чёрный список")])]),t._v(" "),s("p",[t._v("Прошивка UEFI, поддерживающая безопасную загрузку, всегда находится в одном из трех состояний:")]),t._v(" "),s("ul",[s("li",[t._v("Setup mode, Secure Boot off")]),t._v(" "),s("li",[t._v("User mode, Secure Boot off")]),t._v(" "),s("li",[t._v("User mode, Secure Boot on")])]),t._v(" "),s("p",[t._v("В режиме настройки любое приложение UEFI может изменять или удалять PK, добавлять/удалять ключи из KEK, а также добавлять/удалять записи белого списка или черного списка из db или dbx.")]),t._v(" "),s("p",[t._v("В пользовательском режиме, независимо от того, включена или выключена Безопасная загрузка:")]),t._v(" "),s("ul",[s("li",[t._v("PK может быть изменен или удален только приложением UEFI, у которого уже есть текущий PK.")]),t._v(" "),s("li",[t._v("Ключи могут быть добавлены/удалены из KEK только приложением UEFI, имеющим PK.")]),t._v(" "),s("li",[t._v("Записи белого списка и черного списка могут быть добавлены/удалены из db и dbx только приложением UEFI, у которого есть любой из ключей в KEK.")])]),t._v(" "),s("p",[t._v("Наконец, в пользовательском режиме с включенной безопасной загрузкой приложения UEFI должны соответствовать одному из следующих четырех требований для запуска:")]),t._v(" "),s("ul",[s("li",[t._v("Подписано, с подписью в db, а не в dbx")]),t._v(" "),s("li",[t._v("Подписано ключом в db, а не в dbx")]),t._v(" "),s("li",[t._v("Подписано ключом в КЕК")]),t._v(" "),s("li",[t._v("Не подписано, но хэш приложения находится в db, а не в dbx")])]),t._v(" "),s("p",[t._v("Обратите внимание, что приложения UEFI не подписываются PK, если только PK также не находится в KEK.")]),t._v(" "),s("p",[t._v("Не все прошивки UEFI поддерживают безопасную загрузку, хотя это является обязательным требованием для Windows 8. Некоторые прошивки UEFI поддерживают безопасную загрузку, и нет возможности отключить их, что создает проблему для независимых разработчиков, которые не имеют доступа к PK или любому из ключей в KEK и, следовательно, не могут установить свой собственный ключ или подпись приложения или хэш в базу данных белого списка. Независимые разработчики должны разрабатывать используя системы, которые либо не поддерживают безопасную загрузку, либо имеют возможность отключить безопасную загрузку.")]),t._v(" "),s("h3",{attrs:{id:"как-использовать-uefi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#как-использовать-uefi"}},[t._v("#")]),t._v(" Как использовать UEFI")]),t._v(" "),s("p",[t._v("Традиционные операционные системы, такие как Windows и Linux, имеют существующую программную архитектуру и большую базу кода для выполнения конфигурации системы и обнаружения устройств. С их сложными уровнями абстракции они не получают прямой выгоды от UEFI. В результате их загрузчики UEFI мало что делают, кроме подготовки среды для их запуска.")]),t._v(" "),s("p",[t._v('Независимый разработчик может найти больше пользы в использовании UEFI для написания полнофункциональных приложений UEFI, а не в том, чтобы рассматривать UEFI как временную среду запуска, которую можно выбросить во время процесса загрузки. В отличие от устаревших загрузчиков, которые обычно взаимодействуют с BIOS только для запуска ОС, приложение UEFI может реализовать сложное поведение с помощью UEFI. Другими словами, независимый разработчик не должен спешить покидать "UEFI-land".')]),t._v(" "),s("p",[t._v('Хорошей отправной точкой является написание приложения UEFI, которое использует системную таблицу для извлечения карты памяти и использует протокол "File" для чтения файлов с дисков в формате FAT. Следующим шагом может быть использование системной таблицы для поиска таблиц ACPI.')]),t._v(" "),s("h2",{attrs:{id:"разработка-с-posix-uefi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#разработка-с-posix-uefi"}},[t._v("#")]),t._v(" Разработка с POSIX-UEFI")]),t._v(" "),s("p",[t._v("Простой способ компиляции приложений EFI в Linux (или любой другой системе, совместимой с POSIX) - это POSIX-UEFI. Он не только предоставляет хорошо известный libc-подобный API для вашего приложения EFI, но и генерирует Makefile, который поможет обнаружить и настроить набор инструментов для вас. Работает как с GNU gcc, так и с LLVM CLang.")]),t._v(" "),s("p",[t._v("Он имеет POSIX-измененные типы (например, uintn_t вместо UINTN), и ему не нужны стандартные заголовки EFI. Но если вы установите их из EDK2 или GNU-EFI, вы также сможете безопасно включить их, конфликтов имен не будет. Тем не менее, эти интерфейсы правильно определены, и все поля имеют точно такое же имя, как и в EDK2, так что это большое преимущество перед GNU-EFI.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("ST"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ConOut"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("OutputString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ST"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ConOut"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hi!\\r\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v('Типичный "Hello World" на UEFI выглядит примерно так:')]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<uefi.h>")])]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("argv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, world!\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("А Makefile выглядит вот так:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("TARGET "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("efi\ninclude uefi"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Makefile\n")])])]),s("p",[t._v("Теперь просто запусти сборку командой "),s("strong",[t._v("make")]),t._v(" и на выходе получишь файл main.efi")]),t._v(" "),s("h2",{attrs:{id:"разработка-с-gnu-efi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#разработка-с-gnu-efi"}},[t._v("#")]),t._v(" Разработка с GNU-EFI")]),t._v(" "),s("p",[t._v("GNU-EFI можно использовать для разработки как 32-разрядных, так и 64-разрядных приложений UEFI. В этом разделе будут рассмотрены только 64-разрядные приложения UEFI и предполагается, что сама среда разработки работает в системе x86_64, поэтому кросс-компилятор не требуется.")]),t._v(" "),s("p",[t._v("GNU-EFI включает в себя следующие вещи:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("crt0-efi-x86_64.o")]),t._v(': CRT0 (код инициализации среды выполнения C), обеспечивающий точку входа, которую микропрограмма UEFI вызовет при запуске приложения, которое, в свою очередь, вызовет функцию "efi_main", записанную разработчиком.')]),t._v(" "),s("li",[s("strong",[t._v("libgnuefi.a")]),t._v(": Библиотека, содержащая одну функцию (_relocate), которая используется CRT0.")]),t._v(" "),s("li",[s("strong",[t._v("elf_x86_64_efi.lds")]),t._v(": Скрипт компоновщика, используемый для связывания двоичных файлов ELF в приложения UEFI.")]),t._v(" "),s("li",[s("strong",[t._v("efi.h")]),t._v(" и другие заголовки: Удобные заголовки, которые предоставляют структуры, типы и константы, улучшают читаемость при доступе к системной таблице и другим ресурсам UEFI.")]),t._v(" "),s("li",[s("strong",[t._v("libefi.a")]),t._v(": Библиотека, содержащая удобные функции, такие как вычисление CRC, вычисление длины строки и простая печать текста.")]),t._v(" "),s("li",[s("strong",[t._v("efilib.h")]),t._v(": Заголовок для libefi.a.")])]),t._v(" "),s("p",[t._v("Как минимум, 64-разрядное приложение UEFI должно будет связываться с "),s("strong",[t._v("crt0-efi-x86_64.o")]),t._v(" и "),s("strong",[t._v("libgnuefi.a")]),t._v(" с помощью скрипта компоновщика "),s("strong",[t._v("elf_x86_64_efi.lds")]),t._v(". Скорее всего, вы захотите также использовать предоставленные заголовки и библиотеки удобства, и в этом разделе предполагается, что и в дальнейшем.")]),t._v(" "),s("p",[t._v('Типичный "Hello World" на UEFI выглядит примерно так:')]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<efi.h>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<efilib.h>")])]),t._v("\n \nEFI_STATUS \nEFIAPI \n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("efi_main")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EFI_HANDLE ImageHandle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" EFI_SYSTEM_TABLE "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("SystemTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("InitializeLib")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ImageHandle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SystemTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, world!\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EFI_SUCCESS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Несколько заметок:")]),t._v(" "),s("ul",[s("li",[t._v("efi.h включен, поэтому мы можем использовать такие типы, как EFI_STATUS, EFI_HANDLE и EFI_SYSTEM_TABLE.")]),t._v(" "),s("li",[t._v('При создании 32-разрядного приложения UEFI EFIAPI пуст; GCC скомпилирует функцию "efi_main", используя стандартные вызовы C. При создании 64-разрядного приложения UEFI EFIAPI расширяется до "'),s("strong",[t._v("attribute")]),t._v('((ms_abi))", и GCC скомпилирует функцию "efi_main", используя стандарт о вызовах Microsoft x64, как указано в UEFI. Только функции, которые будут вызываться непосредственно из UEFI (включая main, но также и обратные вызовы), должны использовать стандарт о вызовах UEFI.')]),t._v(" "),s("li",[t._v('"InitializeLib" и "Print" - это удобные функции, предоставляемые libefi.a с прототипами в efilib.h. "InitializeLib" позволяет libefi.a хранить ссылку на ImageHandle и SystemTable, предоставляемые BIOS. "Print" использует эти сохраненные ссылки для вывода строки, обращаясь к функциям, предоставляемым UEFI в памяти. (Позже мы увидим, как найти и вызвать функции, предоставляемые UEFI, вручную.)')])]),t._v(" "),s("p",[t._v("Программа скомпилированна и слинкована как показано ниже:")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("gcc main.c                             "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -c                                 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -fno-stack-protector               "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -fpic                              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -fshort-wchar                      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -mno-red-zone                      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -I /path/to/gnu-efi/headers        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -I /path/to/gnu-efi/headers/x86_64 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -DEFI_FUNCTION_WRAPPER             "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n      -o main.o\n\nld main.o                         "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     /path/to/crt0-efi-x86_64.o     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -nostdlib                      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -znocombreloc                  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -T /path/to/elf_x86_64_efi.lds "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -shared                        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -Bsymbolic                     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -L /path/to/libs               "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -l:libgnuefi.a                 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -l:libefi.a                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n     -o main.so\n\nobjcopy -j .text                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .sdata               "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .data                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .dynamic             "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .dynsym              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .rel                 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .rela                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          -j .reloc               "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          --target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("efi-app-x86_64 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          main.so                 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n          main.efi\n")])])]),s("p",[t._v("В результате вы получите файл main.efi, которые будет весить 44 КБ.")]),t._v(" "),s("h2",{attrs:{id:"эмуляция-с-qemu-и-ovmf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#эмуляция-с-qemu-и-ovmf"}},[t._v("#")]),t._v(" Эмуляция с QEMU и OVMF")]),t._v(" "),s("p",[t._v("Любой последней версии QEMU с последней версией OVMF будет достаточно для запуска приложения UEFI. Исполняемые файлы QEMU доступны для многих платформ, а образ OVMF (OVMF.fd) можно найти на веб-сайте TianoCore. QEMU (без загрузочного диска) можно вызвать, как показано ниже. Чтобы предотвратить попытку загрузки по PXE (сети) в последних версиях QEMU при отсутствии загрузочного диска, используйте "),s("strong",[t._v("-net none")]),t._v(".")]),t._v(" "),s("p",[t._v("Рекомендуется использовать OVMF (для QEMU 1.6 или новее) с параметром "),s("strong",[t._v("pflash")]),t._v(". В приведенных ниже инструкциях предполагается, что у вас есть образ OVMF, разделённый на отдельные разделы CODE и VARS.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("qemu-system-x86_64 -cpu qemu64 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  -drive "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("pflash,format"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("raw,unit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(",file"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("path_to_OVMF_CODE.fd,readonly"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("on "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  -drive "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("pflash,format"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("raw,unit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(",file"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("path_to_OVMF_VARS.fd "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  -net none\n")])])]),s("p",[t._v("Если вы предпочитаете работать через терминал или через SSH/telnet, вы можете запустить QEMU без графической поддержки, используя флаг "),s("strong",[t._v("-nographic")]),t._v(".")]),t._v(" "),s("p",[t._v("Если OVMF не найдет загрузочный диск с правильно названным приложением UEFI (подробнее об этом позже), он попадет в оболочку UEFI.")]),t._v(" "),s("p",[s("img",{attrs:{src:"/OVMF_shell.png",alt:"Оболочка UEFI"}})]),t._v(" "),s("p",[t._v("Вы можете просмотреть список доступных команд с помощью команды "),s("strong",[t._v("help")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"создание-образа-диска"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#создание-образа-диска"}},[t._v("#")]),t._v(" Создание образа диска")]),t._v(" "),s("p",[t._v("Чтобы запустить приложение UEFI, вам нужно будет создать образ диска и представить его в QEMU. Прошивка UEFI ожидает, что приложения UEFI будут храниться в файловой системе FAT12, FAT16 или FAT32 (называемой системным разделом EFI) на диске с разделением GPT. Многие прошивки поддерживают только FAT32, так что это то, что вы захотите использовать. В зависимости от вашей платформы существует несколько различных способов создания образа диска, содержащего ваше приложение UEFI, но все они начинаются с создания обнуленного файла образа диска. Минимальный размер раздела FAT32 составляет 33 548 800 байт, плюс вам понадобится место для первичной и вторичной таблиц GPT, а также некоторое свободное пространство, чтобы раздел можно было правильно выровнять. В этих примерах мы создадим образ диска размером 48 000 000 байт (93750 512-байтовых секторов или 48 МБ).")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/dev/zero "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("of")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/path/to/uefi.img "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("bs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("93750")]),t._v("\n")])])]),s("h4",{attrs:{id:"приложение-uefi-run"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#приложение-uefi-run"}},[t._v("#")]),t._v(" Приложение uefi-run")]),t._v(" "),s("p",[t._v("Приложение uefi-run полезно для быстрого тестирования. Оно создает временный образ FAT, содержащий ваше приложение EFI, и запускает qemu.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("uefi-run -b /path/to/OVMF.fd -q /path/to/qemu app.efi -- "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("дополнительные аргументы для QEMU"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v('uefi-run в настоящее время не собран для какого-либо дистрибутива. Вы можете установить его с помощью cargo (менеджер пакетов Rust) ("cargo install uefi-run").')]),t._v(" "),s("h4",{attrs:{id:"linux-необходим-root-доступ"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux-необходим-root-доступ"}},[t._v("#")]),t._v(" Linux, необходим root-доступ")]),t._v(" "),s("p",[t._v("Этот подход требует root-доступ и использует gdisk, losetup и mkdosfs.")]),t._v(" "),s("p",[t._v("Во-первых, используйте gdisk для создания таблицы разделов GPT с одним системным разделом EFI.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("gdisk /path/to/uefi.img\nGPT "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fdisk")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("gdisk"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.8")]),t._v(".10\n \nPartition table scan:\n  MBR: not present\n  BSD: not present\n  APM: not present\n  GPT: not present\n \nCreating new GPT entries.\n \nCommand "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("? "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("help")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": o\nThis option deletes all partitions and creates a new protective MBR.\nProceed? "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Y/N"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": y\n \nCommand "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("? "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("help")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": n\nPartition number "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("-128, default "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\nFirst sector "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("34")]),t._v("-93716, default "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" or "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("+-"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("KMGTP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(": "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("\nLast sector "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("-93716, default "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("93716")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" or "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("+-"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("KMGTP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(": "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("93716")]),t._v("\nCurrent "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("type")]),t._v(" is "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Linux filesystem'")]),t._v("\nHex code or GUID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("L to show codes, Enter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8300")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": ef00\nChanged "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("type")]),t._v(" of partition to "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'EFI System'")]),t._v("\n \nCommand "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("? "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("help")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": w\n \nFinal checks complete. About to "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),t._v(" GPT data. THIS WILL OVERWRITE EXISTING\nPARTITIONS"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("\n \nDo you want to proceed? "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Y/N"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": y\nOK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" writing new GUID partition table "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GPT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" to uefi.img.\nWarning: The kernel is still using the old partition table.\nThe new table will be used at the next reboot.\nThe operation has completed successfully.\n")])])]),s("p",[t._v("Теперь у вас есть образ диска с таблицей разделов GUID и неформатированный раздел EFI, начиная с сектора 2048. Если вы не отклонились от команд, показанных выше, образ диска будет использовать 512-байтовые секторы, поэтому раздел EFI начинается с байта 1 048 576 и имеет длину 46 934 528 байт.")]),t._v(" "),s("p",[t._v("Используйте losetup для представления раздела в Linux.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("losetup --offset "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1048576")]),t._v(" --sizelimit "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("46934528")]),t._v(" /dev/loop0 /path/to/uefi.img\n")])])]),s("p",[t._v("(Если /dev/loop0 уже используется, вам нужно будет выбрать другое loopback-устройство.)")]),t._v(" "),s("p",[t._v("Отформатируйте раздел в FAT32 с помощью mkdosfs.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("mkdosfs -F "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),t._v(" /dev/loop0\n")])])]),s("p",[t._v('Теперь раздел можно смонтировать, чтобы мы могли копировать в него файлы. В этом примере мы используем каталог "/mnt", но вы также можете создать локальный каталог для временного использования.')]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mount")]),t._v(" /dev/loop0 /mnt\n")])])]),s("p",[t._v("Скопируйте все приложения UEFI, которые вы хотите протестировать, в файловую систему.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cp")]),t._v(" /path/to/main.efi /mnt/\n")])])]),s("p",[t._v("Наконец, размонтируйте раздел и освободите loopback-устройство.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("umount")]),t._v(" /mnt\nlosetup -d /dev/loop0\n")])])]),s("p",[t._v("uefi.img теперь представляет собой образ диска, содержащий первичные и вторичные таблицы GPT, содержащие один раздел типа EFI, содержащий файловую систему FAT32, содержащую одно или несколько приложений UEFI.")]),t._v(" "),s("h4",{attrs:{id:"linux-без-root-доступа"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux-без-root-доступа"}},[t._v("#")]),t._v(" Linux, без root-доступа")]),t._v(" "),s("p",[t._v("Этот подход использует parted, mformat, mcopy и может выполняться с правами пользователя.")]),t._v(" "),s("p",[t._v("Во-первых, используйте parted для создания первичных и вторичных заголовков GPT, а также одного раздела EFI, охватывающего тот же диапазон, что и описанный выше подход.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parted")]),t._v(" /path/to/uefi.img -s -a minimal mklabel gpt\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parted")]),t._v(" /path/to/uefi.img -s -a minimal mkpart EFI FAT16 2048s 93716s\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parted")]),t._v(" /path/to/uefi.img -s -a minimal toggle "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" boot\n")])])]),s("p",[t._v("Теперь создайте новый временный файл образа, который будет содержать данные раздела EFI, и используйте mformat для форматирования его с помощью FAT16.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/dev/zero "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("of")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/tmp/part.img "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("bs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("91669")]),t._v("\nmformat -i /tmp/part.img -h "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),t._v(" -t "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),t._v(" -n "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("64")]),t._v(" -c "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),s("p",[t._v("Используйте mcopy для копирования любых приложений UEFI, которые вы хотите протестировать, в файловую систему.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("mcopy -i /tmp/part.img /path/to/main.efi ::\n")])])]),s("p",[t._v("Наконец, запишите образ раздела в образ основного диска.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/tmp/part.img "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("of")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/path/to/uefi.img "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("bs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("91669")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("seek")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("conv")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("notrunc\n")])])]),s("p",[t._v("uefi.img теперь представляет собой образ диска, содержащий первичные и вторичные таблицы GPT, содержащие один раздел типа EFI, содержащий файловую систему FAT16, содержащую одно или несколько приложений UEFI.")]),t._v(" "),s("h4",{attrs:{id:"freebsd-требуется-root-доступ"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#freebsd-требуется-root-доступ"}},[t._v("#")]),t._v(" FreeBSD, требуется root-доступ")]),t._v(" "),s("p",[t._v("Этот подход требует привилегий root и использует mdconfig, gpart, newfs_msdos и mount_msdosfs.")]),t._v(" "),s("p",[t._v("Сначала создайте узел устройства, который представляет обнуленный образ диска в виде блочного устройства. Это позволит нам работать над ним, используя стандартные инструменты разделения и форматирования.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ mdconfig -f /path/to/uefi.img\nmd0\n")])])]),s("p",[t._v("В этом примере новым блочным устройством является md0. Теперь создайте пустые первичные и вторичные таблицы GPT на устройстве.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ gpart create -s GPT md0\nmd0 created\n")])])]),s("p",[t._v('Теперь мы можем добавить раздел на диск. Мы укажем раздел "EFI", что просто означает, что GPT установит GUID этого раздела для специального типа "EFI". Не все BIOS требуют этого, и раздел по-прежнему можно будет монтировать и просматривать в обычном режиме в Linux, FreeBSD и Windows.')]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ gpart "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" -t efi md0\nmd0p1 added\n")])])]),s("p",[t._v("Затем создайте файловую систему FAT16 на новом разделе. Вы можете указать различные параметры для файловой системы, если хотите, но это не обязательно. В идеале вы бы создали раздел FAT32 для лучшей совместимости прошивки, но FreeBSD, похоже, создает разделы FAT32, которые OVMF не может прочитать.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ newfs_msdos -F "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),t._v(" md0p1\nnewfs_msdos: trim "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" sectors to adjust to a multiple of "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v("\n/dev/md2p1: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("93552")]),t._v(" sectors "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11694")]),t._v(" FAT16 clusters "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4096")]),t._v(" bytes/cluster"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("BytesPerSec")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("SecPerClust")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("ResSectors")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("FATs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("RootDirEnts")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("Media")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0xf0 "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("FATsecs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("46")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("SecPerTrack")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("Heads")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("HiddenSecs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("HugeSectors")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("93681")]),t._v("\n")])])]),s("p",[t._v("Теперь раздел можно смонтировать, чтобы мы могли копировать в него файлы. В этом примере мы используем каталог /mnt, но вы также можете создать локальный каталог для временного использования.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("mount_msdosfs /dev/md0p1 /mnt\n")])])]),s("p",[t._v("Скопируйте все приложения UEFI, которые вы хотите протестировать, в файловую систему.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cp")]),t._v(" /path/to/main.efi /mnt/\n")])])]),s("p",[t._v("Наконец, размонтируйте раздел и освободите устройство.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("umount")]),t._v(" /mnt\n$ mdconfig -d -u md0\n")])])]),s("p",[t._v("uefi.img теперь представляет собой образ диска, содержащий первичные и вторичные таблицы GPT, содержащие один раздел типа EFI, содержащий файловую систему FAT16, содержащую одно или несколько приложений UEFI.")]),t._v(" "),s("h4",{attrs:{id:"macos-не-требуется-root-доступ"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#macos-не-требуется-root-доступ"}},[t._v("#")]),t._v(" macOS, не требуется root-доступ")]),t._v(" "),s("p",[t._v("В Mac OS есть один инструмент (hdiutil), который одновременно создает образ диска и копирует файлы.")]),t._v(" "),s("p",[t._v("Допустим, вы создаете UEFI для x86_64. По определению имя файла должно быть BOOTX64.EFI и этот файл должны находиться в папке /EFI/BOOT.")]),t._v(" "),s("p",[t._v("Во-первых, давайте создадим временную папку, которая будет содержать все файлы и папки, необходимые для загрузки UEFI.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mkdir")]),t._v(" -p diskImage/EFI/BOOT\n")])])]),s("p",[t._v("Во-вторых, давайте скопируем приложение в нужную директорию:")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cp")]),t._v(" bootx64.efi diskImage/EFI/BOOT/BOOTX64.EFI\n")])])]),s("p",[t._v("Наконец, давайте создадим образ диска, разделенный GPT, отформатированный с помощью fat32 (-fs fat32), при необходимости переопределим файл назначения (-ov), определим размер диска (-размер 48m), имя тома (-volname NEWOS), формат файла, в котором будет закодирован диск (-формат UDTO - тот же, что используется для DVD/CD), и исходную папку, содержащую файлы, которые будут скопированы на новый диск:")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("hdiutil create -fs fat32 -ov -size 48m -volname NEWOS -format UDTO -srcfolder diskImage uefi.cdr\n")])])]),s("p",[t._v("uefi.cdr готов к использованию в QEMU.")]),t._v(" "),s("h3",{attrs:{id:"запуск-uefi-приложении"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#запуск-uefi-приложении"}},[t._v("#")]),t._v(" Запуск UEFI-приложений")]),t._v(" "),s("p",[t._v("Как только ваш образ диска будет готов, вы можете вызвать QEMU, как показано ниже.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("qemu-system-x86_64 -cpu qemu64 -bios /path/to/OVMF.fd -drive "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("file")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("uefi.disk,if"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("ide\n")])])]),s("p",[t._v('Когда OVMF попадет в оболочку UEFI, вы увидите дополнительную запись в "Mapping table" с пометкой "FS0". Это указывает на то, что прошивка обнаружила диск, обнаружила раздел и смогла смонтировать файловую систему. Вы можете изучить файловую систему, переключившись на нее с помощью синтаксиса в стиле DOS "FS0:", как показано ниже.')]),t._v(" "),s("p",[s("img",{attrs:{src:"/OVMF_browse_fs.png",alt:"Обзор файловой системы"}})]),t._v(" "),s("p",[t._v("Вы можете запустить приложение UEFI, введя его имя.")]),t._v(" "),s("p",[s("img",{attrs:{src:"/OVMF_run_app.png",alt:"Запуск приложения"}})]),t._v(" "),s("p",[t._v("Обратите внимание, что оболочка UEFI возобновилась после завершения работы приложения. Конечно, если бы это был правильный загрузчик, он никогда бы не возобновился, а скорее запустил ОС.")]),t._v(" "),s("p",[t._v("Некоторые коммерческие прошивки UEFI предоставляют оболочки UEFI или возможность запуска выбранных пользователем приложений UEFI, таких как прошивка, поставляемая с линейкой ноутбуков HP EliteBook. Однако большинство из них не предоставляют эту функциональность конечному пользователю.")]),t._v(" "),s("h3",{attrs:{id:"отладка"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#отладка"}},[t._v("#")]),t._v(" Отладка")]),t._v(" "),s("p",[t._v("OVMF может быть построен в режиме отладки, и он будет выводить сообщения журнала на порт ввода-вывода "),s("strong",[t._v("0x402")]),t._v(". Вы можете использовать некоторые флаги, подобные приведенным ниже, для захвата выходных данных.")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("-debugcon file:uefi_debug.log -global isa-debugcon.iobase"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0x402\n")])])]),s("p",[t._v("Обратите внимание, что релизные сборки не будут выводить отладочные сообщения или будут иметь уменьшенный вывод.")]),t._v(" "),s("h2",{attrs:{id:"запуск-на-реальном-железе"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#запуск-на-реальном-железе"}},[t._v("#")]),t._v(" Запуск на реальном железе")]),t._v(" "),s("h3",{attrs:{id:"nvram-переменные"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nvram-переменные"}},[t._v("#")]),t._v(" NVRAM переменные")]),t._v(" "),s("p",[t._v('Прошивка UEFI представит большинство своих параметров конфигурации через текстовое или графическое меню конфигурации, как и BIOS. Выбор, сделанный в этих меню, сохраняется в чипе NVRAM между перезагрузками. Однако, в отличие от BIOS, разработчик прошивки имеет возможность предоставить некоторые или все эти "переменные NVRAM" операционной системе и конечному пользователю с помощью удобных функций, размещенных в оперативной памяти прошивкой при загрузке.')]),t._v(" "),s("p",[t._v("Модуль ядра Linux efivarfs будет использовать эти функции для перечисления переменных NVRAM в файле /sys/firmware/efi/efivars. Переменные NVRAM также могут быть сброшены из самой оболочки UEFI с помощью команды dmpstore. Порядок загрузки устройства всегда доступен через переменные NVRAM.")]),t._v(" "),s("h3",{attrs:{id:"загружаемые-uefi-приложения"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#загружаемые-uefi-приложения"}},[t._v("#")]),t._v(" Загружаемые UEFI-приложения")]),t._v(" "),s("p",[t._v('Переменные NVRAM порядка загрузки определяют, где прошивка будет искать приложения UEFI, которые будут запущены при загрузке. Хотя это можно изменить (например, установщик ОС может настроить загрузочную запись для жесткого диска, на который она была установлена), прошивка обычно ищет приложение UEFI с именем "BOOT.efi" (для 32-разрядных приложений) или "BOOTX64.efi" (для 64-разрядных приложений), хранящееся в пути "/EFI/BOOT" в файловой системе загрузочного устройства. Это путь и имя по умолчанию для OVMF.')]),t._v(" "),s("p",[t._v("В отличие от приложения UEFI, запущенного из оболочки, если загрузочное приложение UEFI возвращает в BIOS, оно продолжит поиск других загрузочных устройств.")]),t._v(" "),s("h3",{attrs:{id:"открытая-функциональность"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#открытая-функциональность"}},[t._v("#")]),t._v(" Открытая функциональность")]),t._v(" "),s("p",[t._v('Реальные ПК различаются по объему возможностей UEFI, которые они предоставляют пользователю. Например, даже машина класса 3 может не упоминать UEFI в своей конфигурации BIOS и не предлагать оболочку UEFI. Кроме того, некоторые поставщики BIOS делают свои экраны конфигурации прошивки UEFI идентичными экранам конфигурации BIOS. Машины класса 2 могут представлять несколько запутанные меню загрузки и параметры конфигурации. Например, один производитель ноутбуков включает параметр конфигурации для включения/отключения UEFI (т.е. Переключения между поведением UEFI и CSM) под названием "OS: Windows 8". Другой ноутбук, если ему не удастся найти загрузочное приложение UEFI на выбранном загрузочном устройстве (или если это приложение вернет состояние, отличное от EFI_SUCCESS), вернется к поведению CSM, а затем пожалуется, что на диске поврежден MBR.')]),t._v(" "),s("p",[t._v("Чтобы упростить тестирование на реальном оборудовании, вы можете установить загрузочное приложение UEFI на внутренний жесткий диск системы, которое предоставляет меню загрузки, например rEFInd. Это также может быть удобно для сценариев с несколькими загрузками.")]),t._v(" "),s("h3",{attrs:{id:"разработчики-прошивки-для-пк"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#разработчики-прошивки-для-пк"}},[t._v("#")]),t._v(" Разработчики прошивки для ПК")]),t._v(" "),s("p",[t._v("На платформах x86 и x86-64 следующие разработчики BIOS предлагают прошивку UEFI:")]),t._v(" "),s("ul",[s("li",[t._v("AMI (Aptio).")]),t._v(" "),s("li",[t._v("Phoenix (SecureCore, TrustedCore, AwardCore).")]),t._v(" "),s("li",[t._v("Insyde (InsydeH20).")])]),t._v(" "),s("h3",{attrs:{id:"системы-apple"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#системы-apple"}},[t._v("#")]),t._v(" Системы Apple")]),t._v(" "),s("p",[t._v('Системы Apple реализуют EFI 1.0, в отличие от UEFI, с тем отличием, что приложения UEFI загружаются из файловых систем HFS+ вместо FAT12/16/32. Кроме того, эти приложения UEFI должны быть "подписаны" (либо непосредственно, либо путем нахождения в подписанном каталоге) для загрузки. Blessing устанавливает флаги в файловой системе HFS+, которые проверяет прошивка Apple перед загрузкой приложения. Пакет hfsutils с открытым исходным кодом включает поддержку файлов в файловых системах HFS, но не каталогов и не HFS+.')]),t._v(" "),s("h2",{attrs:{id:"uefi-приложения-в-деталях"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uefi-приложения-в-деталях"}},[t._v("#")]),t._v(" UEFI-приложения в деталях")]),t._v(" "),s("h3",{attrs:{id:"бинарныи-формат"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#бинарныи-формат"}},[t._v("#")]),t._v(" Бинарный формат")]),t._v(" "),s("p",[t._v("Исполняемые файлы UEFI-это обычные образы PE32 / PE32+ (Windows x32 / x64) с определенной подсистемой. Каждое приложение UEFI в основном представляет собой исполняемый файл Windows (или DLL) без таблиц символов.")]),t._v(" "),s("p",[s("strong",[t._v("Типы UEFI-образов")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Тип")]),t._v(" "),s("th",[t._v("Описание")]),t._v(" "),s("th",[t._v("Подсистема")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Приложения")]),t._v(" "),s("td",[t._v("Загрузчики ОС и другие утилиты.")]),t._v(" "),s("td",[t._v("10")])]),t._v(" "),s("tr",[s("td",[t._v("Драйвер службы загрузки")]),t._v(" "),s("td",[t._v("Драйверы, используемые встроенным ПО при загрузке (например, драйверы дисков, сетевые драйверы).")]),t._v(" "),s("td",[t._v("11")])]),t._v(" "),s("tr",[s("td",[t._v("Драйвер среды выполнения")]),t._v(" "),s("td",[t._v("Драйверы, которые могут оставаться загруженными даже после загрузки ОС и выхода из службы загрузки.")]),t._v(" "),s("td",[t._v("11")])])])]),t._v(" "),s("p",[t._v("Образы UEFI также должны указывать тип машинного кода, который они содержат. Загрузчик UEFI откажется загружать несовместимый образ.")]),t._v(" "),s("p",[s("strong",[t._v("Типы машин")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Название")]),t._v(" "),s("th",[t._v("Значение")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("x86")]),t._v(" "),s("td",[t._v("0x014c")])]),t._v(" "),s("tr",[s("td",[t._v("x86_64")]),t._v(" "),s("td",[t._v("0x8664")])]),t._v(" "),s("tr",[s("td",[t._v("Itanium x64")]),t._v(" "),s("td",[t._v("0x0200")])]),t._v(" "),s("tr",[s("td",[t._v("UEFI Byte Code")]),t._v(" "),s("td",[t._v("0x0EBC")])]),t._v(" "),s("tr",[s("td",[t._v("ARM")]),t._v(" "),s("td",[t._v("0x01C2")])]),t._v(" "),s("tr",[s("td",[t._v("AArch (ARM x64)")]),t._v(" "),s("td",[t._v("0xAA64")])]),t._v(" "),s("tr",[s("td",[t._v("RISC-V x32")]),t._v(" "),s("td",[t._v("0x5032")])]),t._v(" "),s("tr",[s("td",[t._v("RISC-V x64")]),t._v(" "),s("td",[t._v("0x5064")])]),t._v(" "),s("tr",[s("td",[t._v("RISC-V x128")]),t._v(" "),s("td",[t._v("0x5128")])])])]),t._v(" "),s("p",[t._v("ARM означает, что вы можете использовать инструкции Thumb/Thumb 2, но интерфейсы UEFI находятся в режиме ARM.")]),t._v(" "),s("h4",{attrs:{id:"инициализация"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#инициализация"}},[t._v("#")]),t._v(" Инициализация")]),t._v(" "),s("p",[t._v("Приложения должны либо загрузить ОС и выйти из служб загрузки, либо вернуться из основной функции (в этом случае загрузчик будет искать следующее загружаемое приложение).")]),t._v(" "),s("p",[t._v("Драйверы должны инициализироваться, а затем возвращать 0 при успешном выполнении или код ошибки. Компьютер может не загрузиться, если не загрузится необходимый драйвер.")]),t._v(" "),s("h4",{attrs:{id:"память"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#память"}},[t._v("#")]),t._v(" Память")]),t._v(" "),s("p",[t._v("Карта памяти, возвращаемая UEFI, будет отмечать области памяти, используемые драйверами.")]),t._v(" "),s("p",[t._v("После завершения загрузки ОС ядру разрешается повторно использовать память, в которую был загружен загрузчик.")]),t._v(" "),s("p",[t._v("Типы памяти - "),s("strong",[t._v("Efi{Loader/BootServices/RuntimeServices}{Code/Data}")]),t._v(".")]),t._v(" "),s("p",[t._v("После выхода из служб загрузки вы можете повторно использовать любую память, доступную только для чтения, которую использовали драйверы загрузки.")]),t._v(" "),s("p",[t._v("Однако память, используемая драйверами среды выполнения, никогда не должна быть затронута - драйверы среды выполнения остаются активными и загруженными до тех пор, пока работает компьютер.")]),t._v(" "),s("p",[t._v("Один из способов увидеть разбивку PE-файла, содержащего приложение UEFI, - это")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("objdump --all-headers /path/to/main.efi\n")])])]),s("p",[t._v("Его выход довольно длинный. Среди прочего, он показывает подсистему, то есть тип образа UEFI, упомянутый ранее.")]),t._v(" "),s("h3",{attrs:{id:"соглашение-о-вызовах"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#соглашение-о-вызовах"}},[t._v("#")]),t._v(" Соглашение о вызовах")]),t._v(" "),s("p",[t._v("UEFI определяет следующие соглашения о вызовах:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("cdecl")]),t._v(" для x86 UEFI-функций")]),t._v(" "),s("li",[s("strong",[t._v("Microsoft's 64-bit calling convention")]),t._v(" для x86-64 UEFI-функций")]),t._v(" "),s("li",[s("strong",[t._v("SMC")]),t._v(" для ARM UEFI-функций")])]),t._v(" "),s("p",[t._v("Это оказывает два влияния на разработчиков приложений UEFI:")]),t._v(" "),s("ul",[s("li",[t._v("Основная точка входа приложения UEFI должна ожидать вызова с соответствующим соглашением о вызове.")]),t._v(" "),s("li",[t._v("Любые функции, предоставляемые UEFI, которые вызывает приложение UEFI, должны вызываться с соответствующим соглашением о вызовах.")])]),t._v(" "),s("p",[t._v("Обратите внимание, что функции, строго внутренние для приложения, могут использовать любое соглашение о вызовах, которое выберет разработчик.")]),t._v(" "),s("h4",{attrs:{id:"posix-uefi-gnu-efi-and-gcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#posix-uefi-gnu-efi-and-gcc"}},[t._v("#")]),t._v(" POSIX-UEFI, GNU-EFI and GCC")]),t._v(" "),s("p",[t._v('cdecl - это стандартное соглашение о вызовах, используемое GCC, поэтому для записи основной точки входа или вызова функций UEFI в приложении UEFI x86, разработанном с использованием GNU-EFI, не требуется никаких специальных атрибутов или модификаторов. Однако для x86-64 функция точки входа должна быть объявлена с модификатором "'),s("em",[s("strong",[t._v("attribute")])]),t._v('((ms_abi))", и все вызовы функций, предоставляемых UEFI, должны выполняться через функцию "uefi_call_wrapper". Этот преобразователь вызывается с помощью cdecl, но затем преобразуется в соглашение о вызове Microsoft x86-64 перед вызовом запрошенной функции UEFI. Это необходимо, поскольку более старые версии GCC не поддерживают указание соглашений о вызовах для указателей функций.')]),t._v(" "),s("p",[t._v('Для POSIX-UEFI, который также использует GCC, ваша точка входа выглядит как стандартная main(), и никакого специального ABI не требуется. Кроме того, среда сборки заботится о флагах компилятора для вас, поэтому вы можете просто вызывать функции UEFI без "uefi_call_wrapper", независимо от того, используете ли вы gcc или другой кросс-компилятор.')]),t._v(" "),s("p",[t._v('Для удобства разработчиков как POSIX-UEFI, так и GNU-EFI предоставляют макрос "EFIAPI", который расширяется до "cdecl" при таргетинге на x86 и "'),s("strong",[t._v("attribute")]),t._v('(ms_abi))" при таргетинге на x86-64. Кроме того, функция "uefi_call_wrapper" просто передаст вызов на x86. Это позволяет использовать один и тот же исходный код для x86 и x86-64. Например, следующая основная функция будет компилироваться с правильным соглашением о вызове как на x86, так и на x86-64, и вызов через функцию "uefi_call_wrapper" выберет правильное соглашение о вызове для использования при вызове функции UEFI (в данном случае вывод строки).')]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("EFI_STATUS EFIAPI "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("efi_main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EFI_HANDLE ImageHandle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" EFI_SYSTEM_TABLE "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("SystemTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  EFI_STATUS status "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("uefi_call_wrapper")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SystemTable"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ConOut"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("OutputString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SystemTable"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ConOut"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, World!\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" status"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"биндинги-языка"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#биндинги-языка"}},[t._v("#")]),t._v(" Биндинги языка")]),t._v(" "),s("p",[t._v("Приложения UEFI обычно пишутся на языке C, хотя биндинги могут быть написаны для любого другого языка, который компилируется в машинный код. Assembler также является опцией; для FASM доступен файл uefi.inc, который позволяет писать приложения UEFI, как показано ниже.")]),t._v(" "),s("div",{staticClass:"language-nasm extra-class"},[s("pre",{pre:!0,attrs:{class:"language-nasm"}},[s("code",[t._v("format pe64 dll efi\nentry main\n \nsection "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'.text'")]),t._v(" code executable readable\n \ninclude "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'uefi.inc'")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token label function"}},[t._v("main:")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("; Инициализация библиотеки UEFI")]),t._v("\n    InitializeLib\n    jc @f\n \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("; Вызов UEFI-функции для вывода на экран")]),t._v("\n    uefi_call_wrapper ConOut, OutputString, ConOut, _hello\n \n@@: mov "),s("span",{pre:!0,attrs:{class:"token register variable"}},[t._v("eax")]),t._v(", EFI_SUCCESS\n    retn\n \nsection "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'.data'")]),t._v(" data readable writeable\n \n_hello                                  du "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello World'")]),t._v(","),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),t._v(","),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(","),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n \nsection "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'.reloc'")]),t._v(" fixups data discardable\n")])])]),s("p",[t._v("Поскольку приложение UEFI содержит обычный машинный код x86 или x86-64, inline assembly также является опцией в компиляторах, которые ее поддерживают.")]),t._v(" "),s("h3",{attrs:{id:"efi-баиткод"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#efi-баиткод"}},[t._v("#")]),t._v(" EFI байткод")]),t._v(" "),s("p",[t._v("UEFI также включает спецификацию виртуальной машины, основанную на формате байтового кода, называемом EFI Byte Code (EBC), который может использоваться для написания независимых от платформы драйверов устройств, но не приложений UEFI. По состоянию на 2015 год использование EBC было ограниченным.")]),t._v(" "),s("h2",{attrs:{id:"основные-проблемы"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#основные-проблемы"}},[t._v("#")]),t._v(" Основные проблемы")]),t._v(" "),s("h3",{attrs:{id:"мое-приложение-uefi-зависает-сбрасывается-примерно-через-5-минут"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#мое-приложение-uefi-зависает-сбрасывается-примерно-через-5-минут"}},[t._v("#")]),t._v(" Мое приложение UEFI зависает/сбрасывается примерно через 5 минут")]),t._v(" "),s("p",[t._v("Когда управление передается вашему приложению UEFI с помощью встроенного ПО, оно устанавливает таймер на 5 минут, после чего встроенное ПО повторно активируется, поскольку предполагается, что ваше приложение зависло. Прошивка в этом случае обычно пытается сбросить систему (хотя прошивка OVMF в VirtualBox просто приводит к тому, что экран становится черным и зависает). Чтобы противодействовать этому, вам необходимо обновить таймер до истечения времени ожидания. Кроме того, вы можете полностью отключить его с помощью такого кода, как")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("SystemTable"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("BootServices"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SetWatchdogTimer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("Очевидно, что это не проблема для большинства загрузчиков, но может вызвать проблему, если у вас есть интерактивный загрузчик, который ожидает ввода пользователя.")]),t._v(" "),s("h3",{attrs:{id:"мои-загрузчик-зависает-если-я-использую-определенные-пользователем-значения-efi-memory-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#мои-загрузчик-зависает-если-я-использую-определенные-пользователем-значения-efi-memory-type"}},[t._v("#")]),t._v(" Мой загрузчик зависает, если я использую определенные пользователем значения EFI_MEMORY_TYPE")]),t._v(" "),s("p",[t._v('Для функций управления памятью в EFI ОС должна иметься возможность использовать значения "тип памяти" выше 0x80000000 для своих собственных целей. В выпуске прошивки OVFM EFI "r11337" (для Qemu и т.д.) Есть ошибка, при которой прошивка предполагает, что тип памяти находится в диапазоне значений, определенных для собственного использования EFI, и использует тип памяти в качестве индекса массива. Конечным результатом является ошибка "array index out of bounds""; где более высокие значения типа памяти (например, разрешённые значения выше 0x80000000) приводят к сбою 64-разрядной версии прошивки (page fault) и приводят к тому, что 32-разрядная версия прошивки сообщает о неправильных значениях "attribute". Эта же ошибка также присутствует в любой версии прошивки EFI, используемой VirtualBox (которая выглядит как более старая версия OVFM); и я подозреваю (но не знаю), что ошибка может присутствовать в самых разнообразных прошивках, которые были получены из проекта TianoCore (а не только OVFM).')]),t._v(" "),s("h2",{attrs:{id:"внешние-ссылки"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#внешние-ссылки"}},[t._v("#")]),t._v(" Внешние ссылки")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://uefi.org/specifications",target:"_blank",rel:"noopener noreferrer"}},[t._v("UEFI Specifications"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://www.tianocore.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Intel TianoCore EDK2"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/tianocore/tianocore.github.io/wiki/OVMF",target:"_blank",rel:"noopener noreferrer"}},[t._v("OVMF firmware images"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://wiki.phoenix.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Phoenix UEFI Wiki"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://x86asm.net/articles/others/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Sereval articles about UEFI"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.microsoft.com/en-us/download/details.aspx?id=19509",target:"_blank",rel:"noopener noreferrer"}},[t._v("PE specification covering the (U)EFI binary format"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://uefi.blogspot.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Blog about UEFI, with bits about UEFI development"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://internshipatdell.wikispaces.com/file/view/How+to+build+an+UEFI+application.pptx",target:"_blank",rel:"noopener noreferrer"}},[t._v("Presentation guiding through simple UEFI application setup"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Presentation giving an overview of windows uefi booting"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://gitlab.com/bztsrc/posix-uefi",target:"_blank",rel:"noopener noreferrer"}},[t._v("POSIX-UEFI"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://wikipedia.org/wiki/Extensible_Firmware_Interface",target:"_blank",rel:"noopener noreferrer"}},[t._v("Wikipedia Article on EFI"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);