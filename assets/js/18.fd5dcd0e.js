(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{405:function(t,s,a){"use strict";a.r(s);var n=a(52),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"встроенная-сборка"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#встроенная-сборка"}},[t._v("#")]),t._v(" Встроенная сборка")]),t._v(" "),a("h2",{attrs:{id:"основная-информация"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#основная-информация"}},[t._v("#")]),t._v(" Основная информация")]),t._v(" "),a("p",[t._v("Идея встроенной сборки заключается в том, чтобы встроить инструкции ассемблера в код C/C++, используя ключевое слово asm, когда нет другого выбора, кроме как использовать язык ассемблера.")]),t._v(" "),a("h2",{attrs:{id:"обзор"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#обзор"}},[t._v("#")]),t._v(" Обзор")]),t._v(" "),a("p",[t._v("Иногда, даже несмотря на то, что C/C++ является вашим основным языком, вам необходимо использовать некоторый код ассемблера в вашей операционной системе. Будь то из-за экстремальных потребностей в оптимизации или из-за того, что код, который вы реализуете, сильно зависит от оборудования (например, например, вывод данных через порт), результат один и тот же: обойти его невозможно. Вы должны использовать ассемблер.")]),t._v(" "),a("p",[t._v('Один из вариантов, который у вас есть, - это написать функцию asm и вызвать ее, однако могут быть случаи, когда даже накладные расходы на "вызов" слишком велики для вас. В этом случае вам нужна встроенная сборка, что означает вставку произвольных фрагментов asm в середине кода с использованием ключевого слова asm(). Способ работы этого ключевого слова зависит от компилятора. В этой статье описывается, как он работает в GCC, поскольку это, безусловно, самый используемый компилятор в мире ОС.')]),t._v(" "),a("h2",{attrs:{id:"синтаксис"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#синтаксис"}},[t._v("#")]),t._v(" Синтаксис")]),t._v(" "),a("p",[t._v("Это синтаксис для использования ключевого слова asm() в коде C/C++:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" assembler "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" output "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("operands")]),t._v("                   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("optional"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" input "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("operands")]),t._v("                    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("optional"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" clobbered registers "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("list")]),t._v("          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("optional"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Шаблон ассемблера - это в основном код, совместимый с GAS, за исключением случаев, когда у вас есть ограничения, и в этом случае имена регистров должны начинаться с %% вместо %. Это означает, что следующие две строки кода будут перемещать содержимое регистра eax в ebx:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"movl %eax, %ebx"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"movl %%eax, %%ebx"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Теперь вы можете задаться вопросом, почему появляется этот %%. Именно здесь появляется интересная особенность встроенной сборки: вы можете использовать некоторые из ваших переменных C в своем ассемблерном коде. И поскольку, чтобы упростить реализацию этого механизма, GCC называет эти переменные %0, %1 и так Далее в вашем ассемблерном коде, начиная с первой переменной, упомянутой в разделах операндов ввода/вывода. Вы должны использовать этот синтаксис %%, чтобы помочь GCC различать регистры и параметры.")]),t._v(" "),a("p",[t._v("Как именно работают операнды, будет более подробно объяснено в последующих разделах. На данный момент достаточно сказать, что если вы напишете что-то подобное:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v('"movl '),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("eax"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n      movl "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("eax"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v('"\n     '),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"=r"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* вывод */")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"r"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ввод */")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%eax"')]),t._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* регистр */")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("то вам удалось скопировать значение "),a("code",[t._v("a")]),t._v(" в "),a("code",[t._v("b")]),t._v(" с помощью ассемблерного кода, эффективно используя некоторые переменные C в вашем ассемблерном коде. Поздравляю!")]),t._v(" "),a("p",[t._v('Последний раздел "clobbered register" используется для того, чтобы сообщить GCC, что ваш код использует некоторые регистры процессора и что он должен переместить любые активные данные из запущенной программы из этого регистра перед выполнением фрагмента asm. В приведенном выше примере мы перемещаем a в eax в первой инструкции, эффективно стирая ее содержимое, поэтому нам нужно попросить GCC очистить этот регистр от несохраненных данных перед операцией.')]),t._v(" "),a("h3",{attrs:{id:"шаблон-ассемблера"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#шаблон-ассемблера"}},[t._v("#")]),t._v(" Шаблон ассемблера")]),t._v(" "),a("p",[t._v("Шаблон ассемблера определяет встроенные инструкции ассемблера. По умолчанию здесь используется синтаксис AT&T. Если вы хотите использовать синтаксис Intel, "),a("strong",[t._v("-masm=intel")]),t._v(" следует указать в качестве параметра командной строки.")]),t._v(" "),a("p",[t._v("Например, чтобы остановить процессор, вам просто нужно использовать следующую команду:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hlt"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"выходные-операнды"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#выходные-операнды"}},[t._v("#")]),t._v(" Выходные операнды")]),t._v(" "),a("p",[t._v('Выходные операнды используется для того, чтобы указать компилятору/ассемблеру, как он должен обрабатывать переменные C, используемые для хранения некоторых выходных данных из кода ASM. Выходные операнды представляют собой список пар, каждый из которых состоит из строкового литерала, известного как "ограничение", указывающего, где должна быть отображена переменная C (регистры обычно используются для оптимальной производительности), и переменной C для отображения (в скобках).')]),t._v(" "),a("p",[t._v('В ограничении "a" относится к EAX, "b" - к EBX, "c" - к ECX, "d" - к EDX, "S" - к ESI и "D" - к EDI (полный список см. в руководстве GCC), предполагая, что вы разрабатываете для архитектуры IA32. Знак уравнения указывает на то, что ваш ассемблерный код не заботится о начальном значении сопоставленной переменной (что позволяет произвести некоторую оптимизацию). Учитывая все это, теперь совершенно ясно, что следующий код устанавливает EAX = 0.')]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" EAX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"movl $0, %0"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"=a"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EAX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Обратите внимание, что компилятор перечисляет операнд, начинающийся с %0, и что вам не нужно добавлять регистр в список заблокированных регистров, если он используется для хранения выходного операнда. GCC достаточно умен, чтобы самостоятельно решить, что делать.")]),t._v(" "),a("p",[t._v("Начиная с GCC 3.1, вы можете использовать более читаемые метки вместо перечисления, подверженного ошибкам:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" current_task"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"str %[output]"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("output"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"=r"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("current_task"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Эти метки находятся в собственном пространстве имен и не будут сталкиваться с какими-либо идентификаторами C. То же самое можно сделать и для входных операндов.")]),t._v(" "),a("h3",{attrs:{id:"входные-операнды"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#входные-операнды"}},[t._v("#")]),t._v(" Входные операнды")]),t._v(" "),a("p",[t._v("В то время как выходные операнды обычно используются для... хорошо... на выходе входные операнды позволяют параметризовать код ASM, т.е. передавать параметры только для чтения из кода C в блок ASM. Опять же, строковые литералы используются для указания деталей.")]),t._v(" "),a("p",[t._v("Если вы хотите переместить какое-то значение в EAX, вы можете сделать это следующим образом (хотя, конечно, было бы довольно бесполезно делать это вместо прямого сопоставления значения с EAX):")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" randomness "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"movl %0, %%eax"')]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"b"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("randomness"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"eax"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Обратите внимание, что GCC всегда будет предполагать, что входные операнды доступны только для чтения (без изменений). Правильная вещь, которую нужно сделать, когда входные операнды записываются, - это перечислить их в качестве выходных данных, но без использования знака уравнения, потому что на этот раз их исходное значение имеет значение. Вот простой пример:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mov %%eax,%%ebx"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// бесполезно, но идея крутая")]),t._v("\n")])])]),a("h3",{attrs:{id:"список-сбитых-регистров"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#список-сбитых-регистров"}},[t._v("#")]),t._v(" Список сбитых регистров")]),t._v(" "),a("p",[t._v("Важно помнить одну вещь: компилятор C/C++ ничего не знает об ассемблере. Для компилятора оператор asm непрозрачен, и если вы не указали никаких выходных данных, он может даже прийти к выводу, что это не операция, и оптимизировать его. Некоторые сторонние документы указывают, что использование asm volatile приведет к тому, что ключевое слово не будет перемещено. Однако, согласно документации GCC, ключевое слово volatile указывает на то, что инструкция имеет важные побочные эффекты. GCC не удалит изменчивый asm, если он доступен, что указывает только на то, что он не будет удален (т.е. вопрос о том, может ли он все еще быть перемещен, остается без ответа). Подход, который должен работать, состоит в том, чтобы использовать asm (volatile) и помещать память в регистры clobber, например:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("__asm__")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cli"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"memory"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Это приведет к тому, что оператор не будет перемещен, но он может быть оптимизирован.")]),t._v("\n__asm__ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("__volatile__")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cli"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"memory"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Это приведет к тому, что оператор не будет ни перемещен, ни оптимизирован.")]),t._v("\n")])])]),a("p",[t._v("Поскольку компилятор использует регистры процессора для внутренней оптимизации ваших переменных C/C++ и не знает об опкодах ASM, вы должны предупредить его о любых регистрах, которые могут быть заблокированы в качестве побочного эффекта, чтобы компилятор мог сохранить их содержимое перед вызовом ASM.")]),t._v(" "),a("p",[t._v("Список сбитых регистров представляет собой разделенный запятыми список имен регистров в виде строковых литералов.")]),t._v(" "),a("h3",{attrs:{id:"wildcards-как-вы-можете-позволить-компилятору-выбирать"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wildcards-как-вы-можете-позволить-компилятору-выбирать"}},[t._v("#")]),t._v(" Wildcards: как вы можете позволить компилятору выбирать")]),t._v(" "),a("p",[t._v("Вам не нужно указывать компилятору, какой конкретный регистр он должен использовать в каждой операции, и в целом, за исключением случаев, когда у вас есть веские причины предпочесть один конкретный регистр, вам лучше позволить компилятору решать за вас.")]),t._v(" "),a("p",[t._v("Например, принудительное использование EAX над любым другим регистром может вынудить компилятор выдать код, который сохранит то, что ранее было в eax, в каком-либо другом регистре или может ввести нежелательные зависимости между операциями (нарушена оптимизация).")]),t._v(" "),a("p",[t._v('Ограничения "wildcards" позволяют предоставить больше свободы GCC, когда дело доходит до сопоставления ввода/вывода:')]),t._v(" "),a("p",[t._v('Ограничение "g":')]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"movl $0, %0"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"=g"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// x может быть тем, что предпочитает компилятор: регистром, ссылкой на память. Это может быть даже буквальная константа в другом контексте.")]),t._v("\n")])])]),a("p",[t._v('Ограничение "r":')]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"movl %%es, %0"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"=r"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// вы хотите, чтобы x прошел через реестр. Если x не был оптимизирован как регистр, компилятор переместит его в нужное место. Это означает, что "movl %0, %%es" : : "r" (0x38) достаточно для загрузки регистра сегмента.')]),t._v("\n")])])]),a("p",[t._v('Ограничение "N":')]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"outl %0, %1"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"N"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x21")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// указывает, что значение "0x21" может использоваться в качестве константы в результате или в работе, если оно находится в диапазоне от 0 до 255')]),t._v("\n")])])]),a("p",[t._v("Конечно, существует гораздо больше ограничений, которые вы можете наложить на выбор операнда, зависящего от машины или нет, которые перечислены в руководстве GCC (см. "),a("a",{attrs:{href:"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Simple-Constraints.html#Simple-Constraints",target:"_blank",rel:"noopener noreferrer"}},[t._v("1"),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Modifiers.html#Modifiers",target:"_blank",rel:"noopener noreferrer"}},[t._v("2"),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Multi_002dAlternative.html#Multi_002dAlternative",target:"_blank",rel:"noopener noreferrer"}},[t._v("3"),a("OutboundLink")],1),t._v(", и "),a("a",{attrs:{href:"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Machine-Constraints.html#Machine-Constraints",target:"_blank",rel:"noopener noreferrer"}},[t._v("4"),a("OutboundLink")],1),t._v(").")]),t._v(" "),a("h2",{attrs:{id:"использование-c99"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#использование-c99"}},[t._v("#")]),t._v(" Использование C99")]),t._v(" "),a("p",[t._v("asm не является ключевым словом при использовании "),a("strong",[t._v("gcc-std=c99")]),t._v(". Просто используйте "),a("strong",[t._v("gcc -std=gnu99")]),t._v(", чтобы использовать C99 с расширениями GNU. Кроме того, вы можете использовать _"),a("em",[t._v("asm")]),t._v("_ в качестве альтернативного ключевого слова, которое работает даже тогда, когда компилятор строго придерживается стандарта.")]),t._v(" "),a("h2",{attrs:{id:"назначение-меток"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#назначение-меток"}},[t._v("#")]),t._v(" Назначение меток")]),t._v(" "),a("p",[t._v("Можно назначить так называемые метки ASM ключевым словам C/C++. Это можно сделать с помощью команды asm для определений переменных, как показано в этом примере:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" some_obscure_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"param"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "param" будет доступен во встроенной сборке')]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mov param, %%eax"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Вот пример того, как вы можете получить доступ к этим переменным, если вы явно не указываете имя:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" some_obscure_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mov some_obscure_name, %%eax"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Обратите внимание, что вам также может потребоваться использовать "),a("strong",[t._v("_some_obscure_name")]),t._v(" (с начальным подчеркиванием), в зависимости от ваших параметров компоновки.")]),t._v(" "),a("h2",{attrs:{id:"asm-goto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asm-goto"}},[t._v("#")]),t._v(" asm goto")]),t._v(" "),a("p",[t._v("До GCC 4.5 переход через встроенные asm не поддерживался. Компилятор не может отслеживать, что происходит, поэтому почти гарантированно будет сгенерирован неправильный код.")]),t._v(" "),a("p",[t._v('Возможно, вам сказали, что "гото-это зло". Если вы верите, что это так, то asm goto-это ваш худший кошмар, который сбывается. Тем не менее, он предлагает некоторые интересные варианты оптимизации кода.')]),t._v(" "),a("p",[t._v("asm goto не очень хорошо документирован, но его синтаксис выглядит следующим образом:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("goto")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"jmp %l[labelname]"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* нет вывода */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ввод */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"memory"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" labelname "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* любые метки */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Одним из примеров, где это может быть полезно, является инструкция CMPXCHG (см. "),a("a",{attrs:{href:"https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%BE%D0%BC",target:"_blank",rel:"noopener noreferrer"}},[t._v("Сравнение c Обменом"),a("OutboundLink")],1),t._v("), которую исходный код ядра Linux определяет следующим образом:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdint.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("cmpxchg")]),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _old"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _new "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uint32_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__ptr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uint32_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uint32_t")]),t._v(" __ret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                                     ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lock; cmpxchgl %2,%1"')]),t._v("           "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"=a"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__ret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"+m"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("                ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"r"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_new"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_old"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("                     ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"memory"')]),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t\t\t ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                                             ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[t._v("__ret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                                         ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])])]),t._v("\n")])])]),a("p",[t._v("В дополнение к возвращению текущего значения в EAX, CMPXCHG устанавливает нулевой флаг (Z) при успешном выполнении. Без asm goto ваш код должен будет проверить возвращаемое значение; этой инструкции CMP можно избежать следующим образом:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Работает на x86 и x86-64")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdint.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("cmpxchg")]),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _old"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _new"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fail_label "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uint32_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__ptr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uint32_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("goto")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lock; cmpxchg %1,%0 \\t\\n"')]),t._v("           "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"jnz %l["')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("fail")]),a("span",{pre:!0,attrs:{class:"token expression"}},[t._v("_label ")])])]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"] \\t\\n"')]),t._v("               "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ничего */")]),t._v("                                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"m"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"r"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_new"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_old"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("       ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"memory"')]),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cc"')]),t._v("                             "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" fail_label "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                              ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])])]),t._v("\n")])])]),a("p",[t._v("Затем этот новый макрос можно использовать следующим образом:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Item")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Item")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Item")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addItem")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Item")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Item")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" oldHead"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nagain"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  oldHead "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oldHead"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cmpxchg")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" oldHead"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" again"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"синтаксис-intel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#синтаксис-intel"}},[t._v("#")]),t._v(" Синтаксис Intel")]),t._v(" "),a("p",[t._v("Вы можете разрешить GCC использовать синтаксис intel, включив его во встроенной сборке, например:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('".intel_syntax noprefix"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mov eax, ebx"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Аналогично, вы можете вернуться к синтаксису AT&T, используя следующий фрагмент кода:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('".att_syntax prefix"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("asm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mov %ebx, %eax"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("Важно")]),t._v(" "),a("p",[t._v("Таким образом, вы можете объединить синтаксис Intel и встроенную сборку синтаксиса AT&T. Обратите внимание, что как только вы запустите один из этих типов синтаксиса, все, что ниже команды в исходном файле, будет собрано с использованием этого синтаксиса, поэтому не забудьте переключиться обратно, когда это необходимо, или вы можете получить много ошибок компиляции!")])]),t._v(" "),a("p",[t._v("Существует также опция командной строки "),a("strong",[t._v("-masm=intel")]),t._v(" для глобального запуска синтаксиса Intel.")]),t._v(" "),a("h2",{attrs:{id:"внешние-ссылки"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#внешние-ссылки"}},[t._v("#")]),t._v(" Внешние ссылки")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://gcc.gnu.org/onlinedocs/",target:"_blank",rel:"noopener noreferrer"}},[t._v("GCC Manuals"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://web.archive.org/web/20041210030000/http://www-106.ibm.com/developerworks/library/l-ia.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inline assembly for x86 in Linux (by IBM)"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://msdn.microsoft.com/en-us/library/26td21ds(VS.80).aspx",target:"_blank",rel:"noopener noreferrer"}},[t._v("Visual C++ Compiler Intrinsics"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);